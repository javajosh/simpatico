<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>TicTacToe</title>
	<link id="favicon" rel="icon" type="image/png" href="white.png" />
	<meta id="refresh" http-equiv="refresh" content="2">
</head>
<body>
	<h1>TicTacToe.js</h1>
	<p>Josh Rehman <i>20 Jan 2019</i></p>
	<p>deps: utils.js</p>
	<button onclick="window.stop()">Stop 2s Refresh</button>

	<h2>Tic-Tac-Toe in functional ES6</h2>
	<p>Once upon a time a recruiter asked me to code up tic-tac-toe in some language or another. Maybe python or java. But anyway I really like ES6 and wanted to take a stab at it. Generally, I'm very pleased with this overall code. *The vast majority of complexity is in the winner computation*. So the strategy here is to get all the other computation out of the way, and then play around with winner algorithms.</p>

	<p>One way to think about the algorithm is very close to the metal, and compute it in three phases: across, down, and diagonals. This can be computed on any board and doesn't use the last move as an optimization. It even generalizes pretty well over different board sizes.
</p>

<p>Another approach is to start with the last move, and then take 'slices' of the board in various directions that include that move, and then analyze those slices.</p>

<script src='utils.js'></script>
<script src='combine.js'></script>
<script src='tictactoe.js'></script>
<script>
	"use strict";

	install(window, assertions);

	console.log('Starting tests');
	window.onerror = e => document.getElementById('favicon').href='red.png';
	const skipTo = 0;
	let count = 0;
	const test = (target, msg, expected, print=true) => {
		if (skipTo && count < skipTo){
			count++; 
			return;
		}

		const result = combine(target, msg);

		if (print) log(count++, 'target', target, 'msg', msg, 'expected', expected, 'result', result);

		if (getType(expected) === FUN) expected(result); 
		else deepEquals(expected, result);

		return result;
	};

	const UNIT = {};
	let state;

	state = combine(UNIT, {
		turn: 1, 
		moves: [3,4,1],
		winner: null
	});


	const moveHandler = {
		name: 'move',
		example: {msg: 'move', val: 8},
		handle: function (game, msg) {
			// Sadly I can't do null(game.winner) because null is a reserved word
			assertEquals(game.winner, null, 'Game already won!');

			const move = msg.val;
			between(0,8,move);
			excludes(game.moves, move);

			return [{turn: 1}, {moves: move}, {msg: 'winner', val: 1}];
		},
	};

	const winnerHandler = {
		name: 'winner',
		example: {msg: 'winner', val: null},
		/*
			0 1 2
			3 4 5
			6 7 8
		*/
		winConditions: '012-345-678-036-147-258-048-246',
		handle: function(game, msg){
			const conditions = this.winConditions.split('-');

			const m0 = game.moves.filter((move, i) => i % 2).sort().join('');
			const m1 = game.moves.filter((move, i) => i % 2 - 1).sort().join('');
			console.log('hey', m0, m1);	
			return [];
		}
	};

	state = combine(state, moveHandler);
	state = combine(state, winnerHandler);



	state = combine(state, {msg: 'move', val: 8});
	// test(state, game => game.turn === 2, true);
	// test(state, game => game.moves[0] === 8, true);
	// test(state, game => game.winner === null, true);

	// Doesn't allow non integer, or out of bound moves
	// assertThrows(()=>combine(state, {msg: 'move', val: 'a'}));
	// assertThrows(()=>combine(state, {msg: 'move', val: 18}));

	// // Doesn't allow duplicate moves
	// assertThrows(()=>combine(state, {msg: 'move', val: 8}));



	// result = TicTacToe();
	// result.move(0,0); 
	// result.move(0,1);

	console.log('Tests succeeded!');
	document.getElementById('favicon').href='green.png';
</script>
</body>
</html>

