<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>TicTacToe</title>
	<link id="favicon" rel="icon" type="image/png" href="white.png" />
	<meta id="refresh" http-equiv="refresh" content="2">
</head>
<body>
	<h1>TicTacToe.js</h1>
	<p>Josh Rehman <i>20 Jan 2019</i></p>
	<p>deps: utils.js, combine.js</p>
	<button onclick="window.stop()">Stop 2s Refresh</button>

	<h2>Tic-Tac-Toe using Combine.js</h2>
	<p>
		Putting aside some interesting things about the winner algorithm (here I opted for the simplest possible thing, a straight-forward, easy string matching problem), this demo is really about using <code>combine()</code> with a finite state machine that halts. This demo has a lot of features, like a turn counter, complete input validation. 
	</p>

	<p>
		One of the things I wanted but didn't do yet is implement the "friendly function convention", where the handlers would <i>tell</i> the world what they expect for messages, both statically and dynamically. However, the predicate language isn't quite ready so that will have to wait. In the meantime this demo demonstrates the ease with which new variations of FSMs can be constructed, at runtime, without traditional inheritence. Next I want to build a visual test harness that lets people build test cases, but also game variations without coding.
	</p>


<script src='utils.js'></script>
<script src='combine.js'></script>
<!-- <script src='tictactoe.js'></script> -->
<script>
	"use strict";

	install(window, assertions);

	log('Starting tests');
	window.onerror = e => document.getElementById('favicon').href='red.png';
	const skipTo = 0;
	let count = 0;
	const test = (target, msg, expected, print=true) => {
		if (skipTo && count < skipTo){
			count++; 
			return;
		}

		const result = combine(target, msg);

		if (print) log(count++, 'target', target, 'msg', msg, 'expected', expected, 'result', result);

		if (getType(expected) === FUN) expected(result); 
		else deepEquals(expected, result);

		return result;
	};

	const UNIT = {};
	let state;

	// Begin actual tic tac toe!

	state = combine(UNIT, {
		turn: 1, 
		moves: [],
		winner: -1,
	});


	const moveHandler = {
		name: 'move',
		example: {msg: 'move', val: 8},
		handle: function (game, msg) {
			assert(game.winner === -1, `Game already won by player ${game.winner}!`);

			const move = msg.val;
			between(0,8,move);
			excludes(game.moves, move);

			return [{turn: 1}, {moves: move}, {msg: 'winner'}];
		},
	};

	const winnerHandler = {
		name: 'winner',
		example: {msg: 'winner'},
		/*
			0 1 2
			3 4 5
			6 7 8
		*/
		winConditions: '012-345-678-036-147-258-048-246'.split('-'),
		handle: function(game, msg){
			// Odd moves are for player one, even for player two
			// Also, lodash has _.partition([1, 2, 3, 4], n => n % 2);
			const p0 = game.moves.filter((move, i) => i % 2 - 1).sort().join('');
			const p1 = game.moves.filter((move, i) => i % 2).sort().join('');

			for (const pattern of this.winConditions){
				if (p0.match(pattern)) return {winner: 1};
				if (p1.match(pattern)) return {winner: 2};
			}
		}
	};

	state = combine(state, moveHandler);
	state = combine(state, winnerHandler);

	// In this game, p0 wins with 012
	state = combine(state, {msg: 'move', val: 0});
	state = combine(state, {msg: 'move', val: 3});
	state = combine(state, {msg: 'move', val: 1});
	state = combine(state, {msg: 'move', val: 8});
	state = combine(state, {msg: 'move', val: 2});

	// Game is won, so no more moves are allowed.
	assertThrows(()=>combine(state, {msg: 'move', val: 7}));


	console.log('Tests succeeded!');
	document.getElementById('favicon').href='green.png';
</script>
</body>
</html>

