<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>çlock</title>
	<style>
		body {margin: 0; font-family: arial; color: white; background-color: black;}
	</style>
</head>
<body>
	<svg width="1000" height="1000" 
		viewBox="-1 -1 2 2" 
    transform="scale(1,-1)"
		style="background-color: #66b7ff"
	>
    <rect class='background' fill="#482" />

    <g transform='translate(.99,0)'><rect width=.01 height=.01 /></g>
    <g transform='translate(0,.99)'><rect width=.01 height=.01 fill='#a30033' /></g>
    <g transform='translate(-1,0)'><rect width=.01 height=.01 fill='#402002' /></g>
    <g transform='translate(0,-1)'><rect width=.01 height=.01 /></g>

  	<g class='clock' 
  		transform1='translate(.5,.5) scale(.5,.5)'
  	>
  		<circle class='unit-circle' r=1 fill="none" stroke="#292911" stroke-width=.001 />
  		<g class='radius' transform='rotate(60)'>
  			<line class='arm' x1=0 y1=0 x2=1 y2=0 stroke="#093232" stroke-width=.001 />
  			<circle class='intersection' r=.05 cx=1 cy=0 fill="red" stroke="none" stroke-width="0" />
  		</g>
  	</g>
	</svg>
<script>
  // Simpatico has three parts: combine, the rtree, and friendly functions.
  // but first we need to normalize the environment in a readable, terse way.

	'use strict';

	const error = a => {throw new Error(a)}
	const assert = (a, msg) => a ? true : error(msg)
	const and = (a,b) => !!a && !!b
	const or = (a,b) => !!a || !!b
  const equals = (a,b) => 
    typeof a === 'object' ? JSON.stringify(a) === JSON.stringify(b) : a === b;
  const identity = a => a
	const all = arr => arr.reduce(and, true)
	const any = arr => arr.reduce(or, false)
	const same = arr => arr.reduce(equals, arr[0])
  const peek = arr => arr.length ? arr[arr.length -1] : null
  const push = (arr, a) => {arr.push(a); return arr} //mutating
  const hasProp = (a, prop) => a.hasOwnProperty(prop)
  const propType = (a, prop) => getType(a[prop])

	const now = a => a ? Date.now() - a : Date.now()
	const log = console.log.bind(console)
	const debug = console.debug.bind(console)
	const info = console.info.bind(console)

  const mapObject = (a,fn) => Object.fromEntries(Object.entries(a).map(fn))

	const assertEquals = (actual, expected, msg) => {
	  assert(equals(actual, expected), `got [${tryToStringify(actual)}] expected [${tryToStringify(expected)}]${msg ? ' msg:' + msg : ''}`)
	};

  // A safer stringify that takes into account circular references.
  const tryToStringify = obj => {
    if (typeof obj !== 'object') return obj;
    let result = '<Circular>';
    try{ result = JSON.stringify(obj); } catch (ignored) {}
    return result;
  }

	const TYPES = {
    // These are the 7 basic JS types, excluding void
    UNDEF: 'undefined',
    NUL: 'null',
    STR: 'string',
    NUM: 'number',
    BOOL: 'boolean',
    FUN: 'function',
    OBJ: 'object',

    // Special types
    ARR: 'array',
    ANY: 'any',
    ELT: 'element', //useful in browsers

    //Simpatico types
    CORE: 'handlers', //a core has handlers
    HANDLER: 'handle', //a hander has a handle function
    MSG: 'handler', //a message points to a handler
	};

	const getType = (a) => {
    const {UNDEF,NUL,STR,FUN,OBJ,ARR,ELT,CORE,HANDLER,MSG} = TYPES;

	  let t = typeof a;
	  if (t !== OBJ)  return t;

	  if (a === null) return NUL;
	  if (Array.isArray(a)) return ARR;
    if (window && (a instanceof Element)) return ELT;

    // Simpatico stuff
	  if (propType(a, HANDLER) === FUN) return HANDLER;
    // if (propType(a, CORE) === OBJ) return CORE;
    if (propType(a, MSG) === STR) return MSG;

	  return OBJ;
	};

  // These type predicates are a map from TYPES to an object where the keys 
  // are [lower cased - maybe?] and the values are functions that check getType 
  const PREDS = mapObject(TYPES,([k,v])=>[k, a => getType(a) === v])
  const ASSERT = mapObject(TYPES,([k,v])=>[k, (a, msg) => {assert(getType(a) === v, msg);return true}]);

  // Cast a string to a particular type
  const cast = (type, str) => {
    const {STR,NUM,BOOL} = TYPES;
    assert(PREDS.STR(str), `string value required; called with [${getType(str)}]`);

    switch (type) {
      case STR:
        return str;
      case NUM:
        const result = 1 * str;
        if (Number.isNaN(result)) throw new Error(`Cannot convert ${str} into a number`);
        return result;
      case BOOL:
        return (str === 'true') ? true : false;
      default:
        throw `casting to type ${type} not supported`
    }
  };


  // The first part of Simpatico is the combine function.
  // Integrate msg into target, producing a new target.
  // Note that there are mutating versions of this floating around,
  // and this version misses the very nice feature of showing the message cascade
  const combine = (target, msg, rules=getRules()) => {
    const {UNDEF,NUL,STR,NUM,BOOL,FUN,OBJ,ARR,ELT,ANY,CORE,HANDLER,MSG} = TYPES;
    let ttarget = getType(target);
    let tmsg = getType(msg);

    // In some cases we erase type (set to "ANY")
    // This saves us from repetative rule writing
    if (ttarget === NUL){
      tmsg = ANY; 
    } else if (tmsg !== NUL) {
      // Functions just invoke, so erase the counter type
      if      (tmsg    === FUN) ttarget = ANY;
      else if (ttarget === FUN) tmsg = ANY;
      // Arrays push, so erase the message type
      else if (ttarget === ARR && tmsg !== ARR) tmsg = ANY;
    }

    // Lookup the rule, throw if you can't find it.
    const ruleKey = ttarget + tmsg;
    const rule = rules[ruleKey];
    if (!rule) {
      throw `rule not found. rule[${ruleKey}] target[${tryToStringify(target)}] msg[${tryToStringify(msg)}]`;
    }

    // Invoke the rule and return
    // debug('combine()=>', 'rule:', ruleKey, 'target:', target, 'msg:', msg );
    const result = rule(target, msg);
    // debug(`result[${tryToStringify(result)}] rule[${ruleKey}] target[${tryToStringify(target)}] msg[${tryToStringify(msg)}]` );
    return result;
  }

  const getRules = () => {
    //Rules for combining things. The first arg is the target, second the message
    //We proceed from the "natural" types to the synthetic types introduced by Simpatico.
    const {UNDEF,NUL,STR,NUM,BOOL,FUN,OBJ,ARR,ELT,ANY,CORE,HANDLER,MSG} = TYPES;
    const rules = {};
    rules[NUL+ANY] = (_,b) => b;

    rules[STR+STR]  = (_,b) => b;
    rules[STR+NUL]  = ()    => '';

    rules[NUM+NUM]  = (a,b) => a + b;
    rules[NUM+STR]  = (_,b) => cast(NUM, b);
    rules[NUM+NUL]  = ()    => 0;

    rules[BOOL+BOOL]= (a,b) => b;
    rules[BOOL+STR] = (_,b) => cast(BOOL, b);
    rules[BOOL+NUL] = (a,_) => !a;

    rules[ARR+ARR]  = (a,b) => a.concat(b);
    rules[ARR+ANY]  = (a,b) => [...a,b];
    rules[ARR+NUL]  = ()    => [];

    rules[FUN+ANY]  = (a,b) => a(b);
    rules[ANY+FUN]  = (a,b) => b(a);

    rules[OBJ+OBJ]  = (a,b) => {
      // B is defensively copied, mutated and returned, not A!
      b = Object.assign({},b);
      for (let prop in a){
        b[prop] = b.hasOwnProperty(prop) ?
          combine(a[prop],b[prop]): //recurse
          a[prop]; 
      }
      return b;
    };

    //Gotcha: handler invocation does mutation
    //mutation: core.msgs will get a push,
    //mutation: msg will get an id, time and children
    //mutation: all results will get the id of the parent
    rules[OBJ+MSG] = (core, msg) => { 
      const {UNDEF, ARR, OBJ} = PREDS;

      // World event - defensively copy because we mutate
      if (UNDEF(msg.parent)) msg = Object.assign({}, msg);

      msg.id = core.msgs.length;
      // msg.time = now();
      core.msgs.push(msg);

      //Find the named handler
      const handler = core.handlers[msg.handler];
      if (!handler) throw `handler not found for call ${JSON.stringify(msg)}`;

      // Invoke the handler.
      // Results should always be an array, so help sloppy handlers
      let results = handler[HANDLER](core, msg);
      if (UNDEF(results)) results = [];
      if (!ARR(results))  results = [results];

      // Build up some more info about the message cascade.
      msg.children = results;

      //Recurse for each result
      for (const result of results){
        // Store the id of the parent to avoid cycles that stop stringification
        if (OBJ(result)) result.parent = msg.id;
        core = combine(core, result); //recurse
      }
      return core;
    };

    //handler registration
    rules[OBJ+HANDLER] = (core, handler) => {
      core = combine(core, {handlers:{}, msgs:[]}); 
      core.handlers[handler.name] = handler;
      return core;
    };
    return rules;
  };

  // Convenience functions that wrap combine
  const combineAll = (arr, core={}) => arr.reduce(combine, core)
  const S = (...args) => combineAll(Array.from(args))

  // Tests
  let foo = {name: 'foo', handle: (core, {d}) => [{a:1}, {c:2, d}]}
  let msg = {handler:'foo', d:3};

  let fib = {name:'fib', handle: ({a=1,b=1})=>[{a:b,b:a+b}]};
  let next = {handler:'fib'};


  /** Docs
     This rtree is implemented with arrays.
     The data-structure looks like this:

     0 - 0 1 2 3 8 {}
     1 - 2 4 5 {}
     2 - 4 6 7 {}
     focus: 0 

     The first column is the row number (included for readability)
     The next number is the parent node for the row.
     The next numbers indicate the values in the order they came in.
     The last object is the residue of the row all the way back to root.

     For example, row 1 {} is ∫[0 1 2 4 5], and row 2 {} is ∫[0 1 2 4 6 7]

     The RTree has a mutable state, the focus, which determines what happens on the next add.

    Row focus is just a number. This is the default.
    Branching focus is an array: [row,col] or [node]

    row ={row, parent, values, residue}
  */
  const rtree = (base = {}, reducer = combine, writeRowToResidue=true) => {
    const {ARR,OBJ} = PREDS;
    let foc = 0;

    const values = [base];
    const rows = [{row:0, parent: null, values:[0], residue: base}];
    if (writeRowToResidue) rows[0].residue.row = 0;

    const add = (value, assertion) => {
      const i = values.length;
      const branching = ARR(foc);
      values.push(value);
      if (!branching){
        const row = rows[foc];
        row.values.push(i);
        row.residue = reducer(row.residue, value);
      } else {
        // The interesting case - we are branching!
        const [rowi, coli] = foc;
        const parentRow = rows[rowi];
        const residue = reducer(parentRow.residue, value);
        if (writeRowToResidue) residue.row = rows.length;
        foc = rows.length;
        rows.push({
          row: rows.length, 
          parent: peek(parentRow.values), 
          values: [i], 
          residue,
        });
      }
      if (assertion) assertion(residue());
      return print();
    }

    // TODO design - decide if supporting columns is actually worth the complexity. I think no..
    // to fully support columns requires a partial reduction that looks something like:
    // partial = (rowi, coli) => row=rows[rowi]; row.values.slice(0,coli).reduce(reducer, partial(row.parent))

    const focus = (a) => {
      assert(a >= 0 && a < rows.length, `focus must be between [0, ${rows.length-1}]`);
      foc = ARR(a) ? [a,rows[a].values.length-1] : a;
      return print();
    }

    const residue = (f=foc) => ARR(f) ? rows[f[0]].residue : rows[f].residue;
    const residues = () => rows.map(row=>row.residue);

    const printRow = (row, summarize) => `${row.row} - [${row.parent === null ? 'n' : row.parent}] ${row.values.join(' ')} {${OBJ(row.residue) ? Object.entries(row.residue).length : row.residue}}`;
    const print = ()=> '\n' + rows.map(printRow).join('\n') + `\n focus: ${foc}`;

    const rowValues = (f=foc) => rows[f].values.map(i=>values[i])

    return {values, rows, add, focus, residue, residues, print, rowValues};
  }

  // Basic Tests
  let sum = (a,b) => a+b;
  let t = rtree(0, sum, false);
  assertEquals(t.residue(0), 0)
  t.add(1); // default is branch 0
  assertEquals(t.residue(0), 1)
  t.add(1); 
  assertEquals(t.residue(0), 2)

  //create branch 1
  t.focus([0])
  t.add(1) 
  assertEquals(t.residue(0), 2)
  assertEquals(t.residue(1), 3)
  t.add(1) // add to the branch
  assertEquals(t.residue(0), 2)
  assertEquals(t.residue(1), 4)
  t.add(1) // add to the branch
  assertEquals(t.residue(0), 2)
  assertEquals(t.residue(1), 5)

  t.focus(0) // go back to branch 0
  t.add(1)
  assertEquals(t.residue(0), 3)
  assertEquals(t.residue(1), 5)
  t.add(1)
  assertEquals(t.residue(0), 4)
  assertEquals(t.residue(1), 5)



  // row index tests
  t = rtree({a:0})
  assertEquals(t.residue(0).row, 0, 'The default row is 0')
  assertEquals(t.residue(0).a, 0)

  t.add({a:1})
  assertEquals(t.residue(0).row, 0, 'The row does not change on add')
  assertEquals(t.residue(0).a, 1)

  t.focus([0])
  t.add({a:1}) //branch from the root node, creating branch 1
  assertEquals(t.residue(0).row, 0, 'The row does not change on add')
  assertEquals(t.residue(0).a, 1)
  assertEquals(t.residue(1).row, 1, 'The new branch gets a new index')
  assertEquals(t.residue(1).a, 2)

  t.add({a:1})  // add to branch 1
  assertEquals(t.residue(0).a, 1)
  assertEquals(t.residue(1).a, 3)

  t.focus(0)
  t.add({a:1}) // add to branch 0
  assertEquals(t.residue(0).a, 2)
  assertEquals(t.residue(1).a, 3)

  assertEquals(t.values.length, 5)


  /** Docs

    With a working RTree we can implement unified inheretence/instantiation.
    We define a type as a set of handlers
    We add handlers one at a time, and then branch to create an instance.
    We can also branch to create a subtype, if the new branch also has handlers.
  */

  // Let's start with a clock.
  t = rtree();
  t.add({
    interval: 200, limit: 10, phase:0, //config
    intervalId: null, ticks: 0, err: null, 
    started: null, stopped: null, duration: null, row: null
  });

  t.add({name: 'start', handle:(c,m)=>{
    if (c.started) return;
    // TODO: support a one-time delay on starting.
    const intervalId = window.setInterval( 
      () => {t.focus(c.row); t.add({handler:'tick'});}, 
      c.interval
    );

    debug('start', now(), 'row', c.row, 'intervalId', intervalId);
    return [{intervalId}, {started:now()}];
  }});

  t.add({name: 'stop', handle:(c,m)=>{
    if (c.stopped) return;
    window.clearInterval(c.intervalId);
    const stopped = now();
    return [{stopped},{duration:stopped-c.started}];
  }});

  t.add({name: 'tick', handle:(c,m)=>{
    debug(t.print());
    return (c.ticks < c.limit) ? {ticks:1} : {handler:'stop'};
  }});

  const start = {handler:'start'}
  const stop = {handler:'stop'}

  // Tests
  // let reps = 10
  // while(reps--){
  //   t.focus([0])
  //   // t.add({limit:reps + ''})
  //   t.add({})
  //   t.add(start)
  // }

  /** Docs
    Clock with a requestAnimationFrame() pump
    The basic raf pattern is fn(){stuff; raf(fn)}.
    Generally this is preferred
  */
  t = rtree();
  t.add({
    interval: 0, limit: 20, delay:0, //config
    intervalId: null, ticks: 0, err: null, 
    started: null, stopped: null, duration: null, row: null,
    debug: false, onTick: null,
  });

  t.add({name: 'start', handle:(c,m)=>{
    const {row, interval, delay, started} = c;
    if (started) throw `row ${row} already started at ${started}`;
    const pump = a => {
      // Gotcha: We cannot access c.ticks and c.stopped directly because 
      // the 'c' here is as it was at the beginning of the row.
      t.focus(row);
      const {ticks, stopped} = t.residue();
      t.add({handler:'tick'});
      if (!stopped) {
        if (interval){
          // Q: Is there a better way to artificially slow down the interval?
          window.setTimeout(() => requestAnimationFrame(pump), interval)
        } else {
          requestAnimationFrame(pump);
        }
      }
    };
    window.setTimeout(pump, delay);
    debug('start', now(), 'row', row);
    return [{ started:now() }];
  }});

  t.add({name: 'stop', handle:(c,m)=>{
    const {started, row} = c;
    // TODO figure out why this throws periodically
    if (c.stopped) throw `row ${row} already stopped ${now() -c.stopped}ms ago`;;
    const stopped = now();
    return [{stopped}, {duration: (stopped - started) }];
  }});

  // Gotcha: by using a static 'tick' we save considerable memory
  t.add({name: 'tick', tick: {ticks: 1}, handle: function(c,m){
    const {ticks, limit, stopped, onTick, debug:deb} = c;
    if (c.stopped) return; // the pump is often sloppy by one tick - can we avoid this? 
    // Fun: it's cool to put stuff here to drive it. there are better ways, but it's fun.
    if (onTick) onTick(c);
    if (deb) debug(t.print());
    return (limit === -1 || ticks < limit) ? this.tick : {handler:'stop'};
  }});

  // Tests - Fun this one sets up a bunch of clocks with staggered starts 
  // let reps = 10
  // while(reps--){
  //   t.focus([0])
  //   t.add({debug:true, delay: reps * 500 + ''})
  //   t.add(start)
  // }
  
  // Test - fun, move a clock around. also demonstrates custom values in the clock
  // this one is brittle because it depends on a DOM elt.
  t.focus([0])
  t.add({
    limit:'-1', 
    elt: document.getElementsByClassName('radius')[0],
    onTick: c => SVG.scatter(c.elt, {transform:`rotate(${c.ticks})`}),
  });
  t.add(start)
  document.onclick = e => t.add(stop)

  /**
    SVG is my favorite browser display technology for applications. But it's 
    pretty hard to use natively. Here are some helper functions that make it 
    easier to use!

    TODO: add better support for complex attributes like transform and path
    TODO: this doesn't really fit here in the mainline, perhaps factor it out
  */
  const SVG = {
    // Scatter Object properties to Element attributes
    // Do not set an attribute if it isn't different
    scatter : (elt, obj) => {
      ASSERT.ELT(elt) && ASSERT.OBJ(obj);
      for (const key in obj){
        const old = elt.getAttribute(key);
        if (obj[key] + '' !== old) 
          elt.setAttribute(key, obj[key]);
      }
    },
    // Gather Element attributes to Object properties
    // Only gather attributes when we have a named property
    // Cast the atttribute according to be consistent with the type of the object value
    gather : (elt, obj) => {
      ASSERT.ELT(elt) && ASSERT.OBJ(obj);
      for (const key in obj){
        if (!elt.hasAttribute(key)) continue;
        const val = elt.getAttribute(key);
        const type = getType(obj[key]);
        obj[key] = cast(type, val);
      }
      return obj;
    },
    // TODO is this worth the complexity?
    parseTransform: (elt) => {
      const result = {};
      const transformList = elt.transform.baseVal;
      for (let transform of transformList){
        const m = transform.matrix;
        switch (transform.type) {
          case 2: result.translate = {x:m.e, y:m.f}; break;
          case 3: result.scale = {x:m.a, y:m.d}; break;
          case 4: result.rotate = {angle: transform.angle}; break; //TODO handle rotate(angle, x, y) form
          case 5: break; // TODO skewX() 
          case 6: break; // TODO skewY(()
          case 1: break; // probably the matrix form.
          default:
        }
      }
      return result;
    },
    renderTransform: obj => {
      let result = '';
      Object.entries(obj).forEach(([key, value]) => {
        const inside = Object.values(value).join(',');
        result += `${key}(${inside})`;
      });
      return result;
    }
  }

  // Tests - SVG
  let radius = document.getElementsByClassName('radius')[0]
  let transform = SVG.parseTransform(radius)
  let transformString = SVG.renderTransform(transform)

  // TODO: Define more devices: keyboard, mouse. And also: screen, disk, and network

  // Let's do some friendly functions!
  // It's tempting to use something like JSON Schema, but that does too much, and it's big
  // How far can be get being naive?

  // TODO make this consisten with the earlier preds
  const preds = {
    str: a => typeof a === 'string',
    num: a => typeof a === 'number',
    bool: a => typeof a === 'boolean',
    fun: a => typeof a === 'function',
    obj: a => typeof a === 'object' && !Array.isArray(a),
    arr: a => Array.isArray(a),
    int: a => typeof a === 'number' && Math.floor(a) === a,
    between: (lo, hi, a) => {
      ASSERT.NUM(lo) && ASSERT.NUM(hi) && assert(lo <= hi);
      if (PREDS.STR(a) || PREDS.ARR(a)) a = a.length;
      return (PREDS.NUM(a)) ? lo <= a && a <= hi : false;
    },
    optional: a => true,
    equals: (a,b) => a === b,
    email: a => preds.str(a) && a.match(/@/),
    hasKey: (a,b) => preds.obj(a) && preds.str(b) && a.hasOwnProperty(b),
    contains: (a,b) => preds.arr(a) && a.includes(b),
  }

  const testPattern = {
    a: ['num', 'between', 0, 10],
    b: ['str'],
    c: ['optional', 'str', 'between', 0, 10],
    d: {
      e: ['num', 'between', 0, 10],
      f: ['optional', 'str', 'between', 3, 8],
    }
  }; 

  // Here's a value that matches
  const testValid = {
    a: 5,
    b: 'hi',
    d: {
      e: 3, 
      f: 'abcd'
    }
  };

  // Here's one that doesn't
  const testNotValid = {
    a: 5,
    b: 'hi',
    d: {
      e: 11, //this one fails.
      f: 'abcd'
    }
  };

  /** docs
    Validate against a pattern obj. Return undefined if pass; return a descriptive object if failed. Special cases: 
      value != object => nothing passes (return pattern)
      pattern = null => nothing passes (return {})
      pattern = {} => everything passes (return undefined)

  */
  const validate = (patternObj, valueObj) => {
    //gotcha: do not use getType predicate because handler !== object, etc
    const isObj = a => typeof a === 'object' && !Array.isArray(a);

    if (!isObj(valueObj)) return patternObj; 
    if (patternObj === null) return {};
    if (patternObj === {}) return undefined;

    assert(isObj(patternObj), `pattern must be an object but was ${tryToStringify(patternObj)}`)

    const result = {};
    let objPass = true;

    for (const [patternKey, patternValue] of Object.entries(patternObj)) {
      const value = valueObj[patternKey];
      let pass = true;
      let failReasons = undefined;

      if (isObj(patternValue)) {
        failReasons = validate(patternValue, value); //recurse
      } else if (PREDS.ARR(patternValue)){
        failReasons = checkValue(patternValue, value); //normal case
      } else { // scalar case
        failReasons = (value === patternValue) ? undefined : ['equals', patternValue];
      }

      pass = !failReasons;
      if (!pass) result[patternKey] = failReasons;
      objPass = objPass && pass;
    }
    return objPass ? undefined : result;
  }

  // Check the value against the array. If pass, return the value; if fail, return an array of failures.
  const checkValue = (predArray, value) => {
    const failedPreds = [];
    let pass = true;
    let allPass = true;
    
    // Loop through the predicates.
    for (let i = 0; i < predArray.length; i++){
      let pred = predArray[i].toLowerCase(); // case of preds doesn't matter

      if (pred === 'between'){ 
        const lo = predArray[i+1];
        const hi = predArray[i+2];
        pass = preds.between(lo, hi, value);
        i += 2;
        if (!pass) {
          failedPreds.push(pred, lo, hi);
        }
      } else if (pred === 'optional'){ //optional means we skip if it's missing
        if (PREDS.UNDEF(value)) {
          return undefined;
        }
      } else { // TODO add support for descriptive values?
        pass = PREDS[pred.toUpperCase()](value);
        if (!pass) failedPreds.push(pred);
      }
      allPass = allPass && pass;
    }
    return allPass ? undefined : failedPreds;
  };

  // Tests checkValue()

  // The normal happy cases
  assertEquals(checkValue(['str'], 'a'), undefined);
  assertEquals(checkValue(['num'], 1), undefined);
  assertEquals(checkValue(['bool'], false), undefined);
  assertEquals(checkValue(['between', 0, 3], 2), undefined);
  assertEquals(checkValue(['optional'], undefined), undefined);

  // Bad scalar matches
  assertEquals(checkValue(['num'], 'a'), ['num']);
  assertEquals(checkValue(['str'], 1), ['str']);
  assertEquals(checkValue(['between', 0, 3], 4), ['between', 0, 3]);

  // Optional doesn't mean you can supply a bad value!
  assertEquals(checkValue(['optional', 'num'], 'a'), ['num']);
  assertEquals(checkValue(['optional', 'between', 0, 3], 4), ['between', 0, 3]);
  assertEquals(checkValue(['optional', 'num', 'between', 0, 3], 'a'), ['num']);

  assertEquals(checkValue(['optional', 'num', 'between', 0, 10], 5), undefined);

  // Tests validate()

  // single key 
  assertEquals(validate({a: ['num']}, {a: 1}), undefined, 'passed key');
  assertEquals(validate({a: ['num']}, {a: 'a'}), {a: ['num']}, 'failed key');
  assertEquals(validate({a: ['num']}, {}), {a: ['num']}, 'missing non-optional');

  // multi key 
  assertEquals(validate({a: ['num'], b:['num']}, {a: 1, b:1}), undefined, 'multi-key success');
  assertEquals(validate({a: ['num'], b:['num']}, {a: 1, b:''}), {b:['num']}, 'multi-key fail');

  // special cases
  assertEquals(validate({},{everything:'passes'}), undefined);
  assertEquals(validate(null, {everything:'fails'}), {});
  assertEquals(validate({a:['num']}, 'every non-obj value fails'), {a:['num']});

  assertEquals(validate({a: 'dec', b:['optional', 'num', 'between', 0, 10]}, {a:'dec'}), undefined);
  assertEquals(validate({handler: 'dec', b:['optional', 'num', 'between', 0, 10]}, {handler:'dec'}), undefined);


  assertEquals(validate({
    e: ['num', 'between', 0, 10],
    f: ['optional', 'str', 'between', 3, 8],
  }, { e: 11, f: "abcd" }), {
    e: ['between', 0, 10]
  });

  // nested object 
  assertEquals(validate({a:['num'], b:{c:['num']}}, {a: 1, b:{c:  1}}), undefined);
  assertEquals(validate({a:['num'], b:{c:['num']}}, {a: 1, b:{c: ''}}), {b:{c:['num']}});

  // the full monty
  assertEquals(validate(testPattern, testValid), undefined, 'full monty should be valid');
  assertEquals(validate(testPattern, testNotValid), {d:{e:['between', 0, 10]}}, 'full monty should NOT be valid');



  /** docs
    A simple friendly function. Note that friendly functions can only take one object arg.
    It's better if they don't return objects if they execute normally.
    We will see that in a handler context these conditions are very natural and easy
  */
  const friendly = input => {
    const pattern = {a:['bool']};
    if (!validate(pattern, input)){ // concern: It's not intuitive to check !validate
      return 2;
    } else {
      return pattern;
    }
  }

  assertEquals(friendly(), {a:['bool']})
  assertEquals(friendly(1), {a:['bool']})
  assertEquals(friendly({a:1}), {a:['bool']})
  assertEquals(friendly({b:true}), {a:['bool']})
  assertEquals(friendly({a:true}), 2)

  // Let's build a little countdown latch
  const latch = rtree({count: 100});
  latch.add({
    name: 'dec',
    desc: 'A counter that goes to 0 in different intervals',
    pattern: {amount:['optional', 'num', 'between', 0, 10]},
    example: {handler: 'dec', amount: 5},
    dec: {count: -1},
    handle: function(ctx, msg){
      const {pattern, dec} = this;
      if (ctx.err) throw `halted with error ${tryToStringify(ctx.err.failures)}`
      const failures = validate(pattern, msg);
      return failures ? {err: {msg, failures}} : 
           msg.amount ? {count: -msg.amount} : dec;
    }
  });

  // Tests
  latch.add({handler: 'dec'}, r => assertEquals(r.count, 99)); 
  latch.add({handler: 'dec', amount: 5}, r => assertEquals(r.count, 94)); 
  latch.add({handler: 'dec', amount: 50},r => assertEquals(r.err.failures, {amount:['between', 0, 10]}));
  latch.add({handler: 'dec', amount: 3});

</script>
</body>
</html>
