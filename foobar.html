<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>çlock</title>
	<style>
		body {margin: 0; font-family: arial; color: white; background-color: black;}
	</style>
</head>
<body>
	<p>open dev tools</p>

	<svg id='coord1' width="1000" height="1000" 
		viewBox="-100 -100 200 200" transform="scale(1,-1)"
		style="background-color: #66b7ff"
	>
    	<rect fill="#482" />
    	<g transform='translate(1,1)'><rect/></g>
    	<g transform='translate(99,0)'><rect width=1 height=1 /></g>
    	<g transform='translate(0,99)'><rect width=1 height=1 fill='#a30033' /></g>
    	<g transform='translate(-100,0)'><rect width=1 height=1 fill='#402002' /></g>
    	<g transform='translate(0,-100)'><rect width=1 height=1 /></g>

		<!-- <polyline points="50 50, 100 100, -100 50" fill=none stroke="gray" stroke-width=1 /> -->

    	<g class='clock' 
    		transform1='translate(50,50) scale(.5,.5)'
    	>
			<circle class='unit-circle' r=100 fill="none" stroke="#292911" stroke-width=.1 />
			<g class='radius' transform='rotate(60)'>
				<line class='arm' x1=0 y1=0 x2=100 y2=0 stroke="#093232" stroke-width=.1 />
				<circle class='intersectin' r=5 cx=100 cy=0 fill="red" stroke="none" stroke-width="0" />
			</g>
    	</g>
	</svg>

	<!-- assume px units -->
	<!-- <svg id='core' width='1000' height='500' viewBox='0 0 1000 500' >

		<rect width="100" height="50" style="stroke: #000000; fill:none;"/>

		<g id='root' transform='translate(0,0)' >
			<g class='entry' transform='translate(0,0)' >
				<g class='key' transform='translate(0,0)' >
					<text class='name'><tspan font-weight="bold">Name:</tspan></text>
				</g>
				<g class='value' transform='translate(100,0)' >
					<text class='name'>Josh</text>
				</g>
			</g>
		</g>
	</svg>

	<svg viewBox="0 0 1000 100">
		<g>
		<desc>Female human</desc>
	    <circle cx="110" cy="56" r="10"/>
	    <polyline points="110 66, 110 80, 100 90, 120 90, 110 80"/>
	    <line x1="104" y1="104" x2="108" y2="90"/>
	    <line x1="112" y1="90" x2="116" y2="104"/>
	    <polyline points="101 70, 110 76, 119 70" />
		</g>
	</svg> -->

<script>
  // Simpatico has three parts: combine, the rtree, and friendly functions.
  // but first we need to normalize the environment in a readable, terse way.
	'use strict';

	const error = a => {throw new Error(a)}
	const assert = (a, msg) => a ? true : error(msg)
	const and = (a,b) => !!a && !!b
	const or = (a,b) => !!a || !!b
	const equals = (a,b) => a === b
  const identity = a => a
	const all = arr => arr.reduce(and, true)
	const any = arr => arr.reduce(or, false)
	const same = arr => arr.reduce(equals, arr[0])
  const peek = arr => arr.length ? arr[arr.length -1] : null
  const push = (arr, a) => {arr.push(a); return arr} //mutating
  const hasProp = (a, prop) => a.hasOwnProperty(prop)
  const propType = (a, prop) => getType(a[prop])

	const now = a => a ? Date.now() - a : Date.now()
	const log = console.log.bind(console)
	const debug = console.debug.bind(console)
	const info = console.info.bind(console)

  const mapObject = (a,fn) => Object.fromEntries(Object.entries(a).map(fn))

	const assertEquals = (expected, actual) => {
	  assert(expected === actual, `expected [${expected}] but got [${actual}]`)
	};

  // A safer stringify that takes into account circular references.
  const tryToStringify = obj => {
    let result = '<Circular>';
    try{ result = JSON.stringify(obj); } catch (ignored) {}
    return result;
  }

	const TYPES = {
    // These are the 7 basic JS types, excluding void
    UNDEF: 'undefined',
    NUL: 'null',
    STR: 'string',
    NUM: 'number',
    BOOL: 'boolean',
    FUN: 'function',
    OBJ: 'object',

    // Special types
    ARR: 'array',
    ANY: 'any',
    ELT: 'element', //useful in browsers

    //Simpatico types
    CORE: 'handlers', //a core has handlers
    HANDLER: 'handle', //a hander has a handle function
    MSG: 'handler', //a message points to a handler
	};

	const getType = (a) => {
    const {UNDEF,NUL,STR,OBJ,ARR,ELT,CORE,HANDLER,MSG} = TYPES;

	  let t = typeof a;
	  if (t !== OBJ)  return t;

	  if (a === null) return NUL;
	  if (a === undefined) return UNDEF;
	  if (Array.isArray(a)) return ARR;
    if (window && (a instanceof Element)) return ELT;

    // Simpatico stuff
	  if (propType(a, HANDLER) === FUN) return HANDLER;
    // if (propType(a, CORE) === OBJ) return CORE;
    if (propType(a, MSG) === STR) return MSG;

	  return OBJ;
	};

  // These type predicates are a map from TYPES to an object where the keys 
  // are [lower cased - maybe?] and the values are functions that check getType 
  const PREDS = mapObject(TYPES,([k,v])=>[k, a => getType(a) === v])
  const ASSERT = mapObject(TYPES,([k,v])=>[k, (a, msg) => assert(getType(a) === v, msg)])

  // Cast a string to a particular type
  const cast = (type, str) => {
    const {STR,NUM,BOOL} = TYPES;
    assert(PREDS.STR(str), `string value required; called with [${getType(str)}]`);

    switch (type) {
      case STR:
        return str;
      case NUM:
        const result = 1 * str;
        if (Number.isNaN(result)) throw new Error(`Cannot convert ${str} into a number`);
        return result;
      case BOOL:
        return (str === 'true') ? true : false;
      default:
        throw `casting to type ${type} not supported`
    }
  };

  // The first part of Simpatico is the combine function.
  // Integrate msg into target, producing a new target.
  // Note that there are mutating versions of this floating around,
  // and this version misses the very nice feature of showing the message cascade
  const combine = (target, msg) => {
    let ttarget = getType(target);
    let tmsg = getType(msg);

    // In some cases we erase type (set to "ANY")
    // This saves us from repetative rule writing
    if (ttarget === NUL){
      tmsg = ANY; 
    } else if (tmsg !== NUL) {
      // Functions just invoke, so erase the counter type
      if      (tmsg    === FUN) ttarget = ANY;
      else if (ttarget === FUN) tmsg = ANY;
      // Arrays push, so erase the message type
      else if (ttarget === ARR && tmsg !== ARR) tmsg = ANY;
    }

    // Lookup the rule, throw if you can't find it.
    const ruleKey = ttarget + tmsg;
    const rule = rules[ruleKey];
    if (!rule) {
      throw `rule not found. rule[${ruleKey}] target[${tryToStringify(target)}] msg[${tryToStringify(msg)}]`;
    }

    // Invoke the rule and return
    // debug('combine()=>', 'rule:', ruleKey, 'target:', target, 'msg:', msg );
    const result = rule(target, msg);
    // debug(`result[${tryToStringify(result)}] rule[${ruleKey}] target[${tryToStringify(target)}] msg[${tryToStringify(msg)}]` );
    return result;
  }

  //Rules for combining things. The first arg is the target, second the message
  //We proceed from the "natural" types to the synthetic types introduced by Simpatico.
  const {UNDEF,NUL,STR,NUM,BOOL,FUN,OBJ,ARR,ELT,ANY,CORE,HANDLER,MSG} = TYPES;
  const rules = {};
  rules[NUL+ANY] = (_,b) => b;

  rules[STR+STR]  = (_,b) => b;
  rules[STR+NUL]  = ()    => '';

  rules[NUM+NUM]  = (a,b) => a + b;
  rules[NUM+STR]  = (_,b) => cast(NUM, b);
  rules[NUM+NUL]  = ()    => 0;

  rules[BOOL+BOOL]= (a,b) => b;
  rules[BOOL+STR] = (_,b) => cast(BOOL, b);
  rules[BOOL+NUL] = (a,_) => !a;

  rules[ARR+ARR]  = (a,b) => a.concat(b);
  rules[ARR+ANY]  = (a,b) => [...a,b];
  rules[ARR+NUL]  = ()    => [];

  rules[FUN+ANY]  = (a,b) => a(b);
  rules[ANY+FUN]  = (a,b) => b(a);

  rules[OBJ+OBJ]  = (a,b) => {
    // B is defensively copied, mutated and returned, not A!
    b = Object.assign({},b);
    for (let prop in a){
      b[prop] = b.hasOwnProperty(prop) ?
        combine(a[prop],b[prop]): //recurse
        a[prop]; 
    }
    return b;
  };

  //Gotcha: handler invocation does mutation
  //mutation: core.msgs will get a push,
  //mutation: msg will get an id, time and children
  //mutation: all results will get the id of the parent
  rules[OBJ+MSG] = (core, msg) => { 
    const {UNDEF, ARR, OBJ} = PREDS;

    // World event - defensively copy because we mutate
    if (UNDEF(msg.parent)) msg = Object.assign({}, msg);

    msg.id = core.msgs.length;
    // msg.time = now();
    core.msgs.push(msg);

    //Find the named handler
    const handler = core.handlers[msg.handler];
    if (!handler) throw `handler not found for call ${JSON.stringify(msg)}`;

    // Invoke the handler.
    // Results should always be an array, so help sloppy handlers
    let results = handler[HANDLER](core, msg);
    if (UNDEF(results)) results = [];
    if (!ARR(results))  results = [results];

    // Build up some more info about the message cascade.
    msg.children = results;

    //Recurse for each result
    for (const result of results){
      // Store the id of the parent to avoid cycles that stop stringification
      if (OBJ(result)) result.parent = msg.id;
      core = combine(core, result); //recurse
    }
    return core;
  };

  //handler registration
  rules[OBJ+HANDLER] = (core, handler) => {
    core = combine(core, {handlers:{}, msgs:[]}); 
    core.handlers[handler.name] = handler;
    return core;
  };

  // Convenience functions that wrap combine
  const combineAll = (arr, core={}) => arr.reduce(combine, core)
  const S = (...args) => combineAll(Array.from(args))

  // Tests
  let foo = {name: 'foo', handle: (core, {d}) => [{a:1}, {c:2, d}]}
  let msg = {handler:'foo', d:3};

  let fib = {name:'fib', handle: ({a=1,b=1})=>[{a:b,b:a+b}]};
  let next = {handler:'fib'};


  /** Docs
     This rtree is implemented with arrays.
     The data-structure looks like this:

     0 - 0 1 2 3 8 {}
     1 - 2 4 5 {}
     2 - 4 6 7 {}
     focus: 0 

     The first column is the row number (included for readability)
     The next number is the parent node for the row.
     The next numbers indicate the values in the order they came in.
     The last object is the residue of the row all the way back to root.

     For example, row 1 {} is ∫[0 1 2 4 5], and row 2 {} is ∫[0 1 2 4 6 7]

     The RTree has a mutable state, the focus, which determines what happens on the next add.

    Row focus is just a number. This is the default.
    Branching focus is an array: [row,col] or [node]

    row ={row, parent, values, residue}
  */
  const rtree = (base = {}, reducer = combine, writeRowToResidue=true) => {
    let foc = 0;

    const {ARR,OBJ} = PREDS;
    const values = [base];
    const rows = [{row:0, parent: null, values:[0], residue: base}];
    if (writeRowToResidue) rows[0].residue.row = 0;

    const add = value => {
      const i = values.length;
      const branching = ARR(foc);
      values.push(value);
      if (!branching){
        const row = rows[foc];
        row.values.push(i);
        row.residue = reducer(row.residue, value);
      } else {
        // The interesting case - we are branching!
        const [rowi, coli] = foc;
        const parentRow = rows[rowi];
        const residue = reducer(parentRow.residue, value);
        if (writeRowToResidue) residue.row = rows.length;
        foc = rows.length;
        rows.push({
          row: rows.length, 
          parent: peek(parentRow.values), 
          values: [i], 
          residue,
        });
      }
      return print();
    }

    // TODO design - decide if supporting columns is actually worth the complexity. I think no..
    // to fully support columns requires a partial reduction that looks something like:
    // partial = (rowi, coli) => row=rows[rowi]; row.values.slice(0,coli).reduce(reducer, partial(row.parent))

    const focus = (a) => {
      assert(a >= 0 && a < rows.length, `focus must be between [0, ${rows.length-1}]`);
      foc = ARR(a) ? [a,rows[a].values.length-1] : a;
      return print();
    }

    const residue = (f=foc) => ARR(f) ? rows[f[0]].residue : rows[f].residue;
    const residues = () => rows.map(row=>row.residue);

    const printRow = (row, summarize) => `${row.row} - [${row.parent === null ? 'n' : row.parent}] ${row.values.join(' ')} {${OBJ(row.residue) ? Object.entries(row.residue).length : row.residue}}`;
    const print = ()=> '\n' + rows.map(printRow).join('\n') + `\n focus: ${foc}`;

    const rowValues = (f=foc) => rows[f].values.map(i=>values[i])

    return {values, rows, add, focus, residue, residues, print, rowValues};
  }

  // Basic Tests
  let sum = (a,b) => a+b;
  let t = rtree(0, sum, false);
  assertEquals(t.residue(0), 0)
  t.add(1); // default is branch 0
  assertEquals(t.residue(0), 1)
  t.add(1); 
  assertEquals(t.residue(0), 2)

  //create branch 1
  t.focus([0])
  t.add(1) 
  assertEquals(t.residue(0), 2)
  assertEquals(t.residue(1), 3)
  t.add(1) // add to the branch
  assertEquals(t.residue(0), 2)
  assertEquals(t.residue(1), 4)
  t.add(1) // add to the branch
  assertEquals(t.residue(0), 2)
  assertEquals(t.residue(1), 5)

  t.focus(0) // go back to branch 0
  t.add(1)
  assertEquals(t.residue(0), 3)
  assertEquals(t.residue(1), 5)
  t.add(1)
  assertEquals(t.residue(0), 4)
  assertEquals(t.residue(1), 5)



  // row index tests
  t = rtree({a:0})
  assertEquals(t.residue(0).row, 0, 'The default row is 0')
  assertEquals(t.residue(0).a, 0)

  t.add({a:1})
  assertEquals(t.residue(0).row, 0, 'The row does not change on add')
  assertEquals(t.residue(0).a, 1)

  t.focus([0])
  t.add({a:1}) //branch from the root node, creating branch 1
  assertEquals(t.residue(0).row, 0, 'The row does not change on add')
  assertEquals(t.residue(0).a, 1)
  assertEquals(t.residue(1).row, 1, 'The new branch gets a new index')
  assertEquals(t.residue(1).a, 2)

  t.add({a:1})  // add to branch 1
  assertEquals(t.residue(0).a, 1)
  assertEquals(t.residue(1).a, 3)

  t.focus(0)
  t.add({a:1}) // add to branch 0
  assertEquals(t.residue(0).a, 2)
  assertEquals(t.residue(1).a, 3)

  assertEquals(t.values.length, 5)


  /** Docs

    With a working RTree we can implement unified inheretence/instantiation.
    We define a type as a set of handlers
    We add handlers one at a time, and then branch to create an instance.
    We can also branch to create a subtype, if the new branch also has handlers.
  */

  // Let's start with a clock.
  t = rtree();
  t.add({
    interval: 200, limit: 10, phase:0, //config
    intervalId: null, ticks: 0, err: null, 
    started: null, stopped: null, duration: null, row: null
  });

  t.add({name: 'start', handle:(c,m)=>{
    if (c.started) return;
    // TODO: support a one-time delay on starting.
    const intervalId = window.setInterval( 
      () => {t.focus(c.row); t.add({handler:'tick'});}, 
      c.interval
    );

    debug('start', now(), 'row', c.row, 'intervalId', intervalId);
    return [{intervalId}, {started:now()}];
  }});

  t.add({name: 'stop', handle:(c,m)=>{
    if (c.stopped) return;
    window.clearInterval(c.intervalId);
    const stopped = now();
    return [{stopped},{duration:stopped-c.started}];
  }});

  t.add({name: 'tick', handle:(c,m)=>{
    debug(t.print());
    return (c.ticks < c.limit) ? {ticks:1} : {handler:'stop'};
  }});

  const start = {handler:'start'}

  // Tests
  // let reps = 10
  // while(reps--){
  //   t.focus([0])
  //   // t.add({limit:reps + ''})
  //   t.add({})
  //   t.add(start)
  // }

  /** Docs
    Clock with a requestAnimationFrame() pump
    The basic raf pattern is fn(){stuff; raf(fn)}.
    Generally this is preferred
  */
  t = rtree();
  t.add({
    interval: 0, limit: 20, delay:0, //config
    intervalId: null, ticks: 0, err: null, 
    started: null, stopped: null, duration: null, row: null,
  });

  t.add({name: 'start', handle:(c,m)=>{
    const {row, interval, delay, started} = c;
    if (started) throw `row ${row} already started at ${started}`;
    const pump = a => {
      // Gotcha: We cannot access c.ticks and c.stopped directly because 
      // the 'c' here is as it was at the beginning of the row.
      t.focus(row);
      const {ticks, stopped} = t.residue();
      t.add({handler:'tick'});
      if (!stopped) {
        if (interval){
          // Q: Is there a better way to artificially slow down the interval?
          window.setTimeout(() => requestAnimationFrame(pump), interval)
        } else {
          requestAnimationFrame(pump);
        }
      }
    };
    window.setTimeout(pump, delay);
    debug('start', now(), 'row', row);
    return [{ started:now() }];
  }});

  t.add({name: 'stop', handle:(c,m)=>{
    const {started, row} = c;
    // TODO figure out why this throws periodically
    if (c.stopped) throw `row ${row} already stopped ${now() -c.stopped}ms ago`;;
    const stopped = now();
    return [{stopped}, {duration: (stopped - started) }];
  }});

  t.add({name: 'tick', handle:(c,m)=>{
    const {ticks, limit, stopped} = c;
    if (c.stopped) return; // the pump is often sloppy by one tick - can we avoid this?
    debug(t.print());
    return (ticks < limit) ? {ticks:1} : {handler:'stop'};
  }});

  // Tests
  let reps = 10
  while(reps--){
    t.focus([0])
    t.add({delay:reps*500 + ''})
    t.add(start)
  }





</script>
</body>
</html>
