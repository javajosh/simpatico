<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>çlock</title>
	<style>
		body {margin: 0; font-family: arial; color: white; background-color: black;}
	</style>
</head>
<body>
	<p>open dev tools</p>

	<svg id='coord1' width="1000" height="1000" 
		viewBox="-100 -100 200 200" transform="scale(1,-1)"
		style="background-color: #66b7ff"
	>
    	<rect fill="#482" />
    	<g transform='translate(1,1)'><rect/></g>
    	<g transform='translate(99,0)'><rect width=1 height=1 /></g>
    	<g transform='translate(0,99)'><rect width=1 height=1 fill='#a30033' /></g>
    	<g transform='translate(-100,0)'><rect width=1 height=1 fill='#402002' /></g>
    	<g transform='translate(0,-100)'><rect width=1 height=1 /></g>

		<!-- <polyline points="50 50, 100 100, -100 50" fill=none stroke="gray" stroke-width=1 /> -->

    	<g class='clock' 
    		transform1='translate(50,50) scale(.5,.5)'
    	>
			<circle class='unit-circle' r=100 fill="none" stroke="#292911" stroke-width=.1 />
			<g class='radius' transform='rotate(60)'>
				<line class='arm' x1=0 y1=0 x2=100 y2=0 stroke="#093232" stroke-width=.1 />
				<circle class='intersectin' r=5 cx=100 cy=0 fill="red" stroke="none" stroke-width="0" />
			</g>
    	</g>
	</svg>

	<!-- assume px units -->
	<!-- <svg id='core' width='1000' height='500' viewBox='0 0 1000 500' >

		<rect width="100" height="50" style="stroke: #000000; fill:none;"/>

		<g id='root' transform='translate(0,0)' >
			<g class='entry' transform='translate(0,0)' >
				<g class='key' transform='translate(0,0)' >
					<text class='name'><tspan font-weight="bold">Name:</tspan></text>
				</g>
				<g class='value' transform='translate(100,0)' >
					<text class='name'>Josh</text>
				</g>
			</g>
		</g>
	</svg>

	<svg viewBox="0 0 1000 100">
		<g>
		<desc>Female human</desc>
	    <circle cx="110" cy="56" r="10"/>
	    <polyline points="110 66, 110 80, 100 90, 120 90, 110 80"/>
	    <line x1="104" y1="104" x2="108" y2="90"/>
	    <line x1="112" y1="90" x2="116" y2="104"/>
	    <polyline points="101 70, 110 76, 119 70" />
		</g>
	</svg> -->

<script>
  // Simpatico has three parts: combine, the rtree, and friendly functions.
  // but first we need to normalize the environment in a readable, terse way.
	'use strict';

	const error = a => {throw new Error(a)}
	const assert = (a, msg) => a ? true : error(msg)
	const and = (a,b) => !!a && !!b
	const or = (a,b) => !!a || !!b
	const equals = (a,b) => a === b
  const identity = a => a
	const all = arr => arr.reduce(and, true)
	const any = arr => arr.reduce(or, false)
	const same = arr => arr.reduce(equals, arr[0])
  const peek = arr => arr.length ? arr[arr.length -1] : null
  const push = (arr, a) => {arr.push(a); return arr} //mutating
  const hasProp = (a, prop) => a.hasOwnProperty(prop)
  const propType = (a, prop) => getType(a[prop])

	const now = a => a ? Date.now() - a : Date.now()
	const log = console.log.bind(console)
	const debug = console.debug.bind(console)
	const info = console.info.bind(console)

  const mapObject = (a,fn) => Object.fromEntries(Object.entries(a).map(fn))

	const assertEquals = (expected, actual) => {
	  assert(expected === actual, `expected [${expected}] but got [${actual}]`)
	};

  // A safer stringify that takes into account circular references.
  const tryToStringify = obj => {
    let result = '<Circular>';
    try{ result = JSON.stringify(obj); } catch (ignored) {}
    return result;
  }

	const TYPES = {
    // These are the 7 basic JS types, excluding void
    UNDEF: 'undefined',
    NUL: 'null',
    STR: 'string',
    NUM: 'number',
    BOOL: 'boolean',
    FUN: 'function',
    OBJ: 'object',

    // Special types
    ARR: 'array',
    ANY: 'any',
    ELT: 'element', //useful in browsers

    //Simpatico types
    CORE: 'handlers', //a core has handlers
    HANDLER: 'handle', //a hander has a handle function
    MSG: 'handler', //a message points to a handler
	};

	const getType = (a) => {
    const {UNDEF,NUL,STR,OBJ,ARR,ELT,CORE,HANDLER,MSG} = TYPES;

	  let t = typeof a;
	  if (t !== OBJ)  return t;

	  if (a === null) return NUL;
	  if (a === undefined) return UNDEF;
	  if (Array.isArray(a)) return ARR;
    if (window && (a instanceof Element)) return ELT;

    // Simpatico stuff
	  if (propType(a, HANDLER) === FUN) return HANDLER;
    // if (propType(a, CORE) === OBJ) return CORE;
    if (propType(a, MSG) === STR) return MSG;

	  return OBJ;
	};

  // These type predicates are a map from TYPES to an object where the keys 
  // are [lower cased - maybe?] and the values are functions that check getType 
  const PREDS = mapObject(TYPES,([k,v])=>[k, a => getType(a) === v])
  const ASSERT = mapObject(TYPES,([k,v])=>[k, (a, msg) => assert(getType(a) === v, msg)])

  // Cast a string to a particular type
  const cast = (type, str) => {
    const {STR,NUM,BOOL} = TYPES;
    assert(PREDS.STR(str), `string value required; called with [${getType(str)}]`);

    switch (type) {
      case STRING:
        return str;
      case NUM:
        const result = 1 * str;
        if (Number.isNaN(result)) throw new Error(`Cannot convert ${str} into a number`);
        return result;
      case BOOL:
        return (str === 'true') ? true : false;
      default:
        throw `casting to type ${type} not supported`
    }
  };

  // The first part of Simpatico is the combine function.
  // Integrate msg into target, producing a new target.
  // Note that there are mutating versions of this floating around,
  // and this version misses the very nice feature of showing the message cascade
  const combine = (target, msg) => {
    let ttarget = getType(target);
    let tmsg = getType(msg);

    // In some cases we erase type (set to "ANY")
    // This saves us from repetative rule writing
    if (ttarget === NUL){
      tmsg = ANY; 
    } else if (tmsg !== NUL) {
      // Functions just invoke, so erase the counter type
      if      (tmsg    === FUN) ttarget = ANY;
      else if (ttarget === FUN) tmsg = ANY;
      // Arrays push, so erase the message type
      else if (ttarget === ARR && tmsg !== ARR) tmsg = ANY;
    }

    // Lookup the rule, throw if you can't find it.
    const ruleKey = ttarget + tmsg;
    const rule = rules[ruleKey];
    if (!rule) {
      throw `rule not found. rule[${ruleKey}] target[${tryToStringify(target)}] msg[${tryToStringify(msg)}]`;
    }

    // Invoke the rule and return
    // debug('combine()=>', 'rule:', ruleKey, 'target:', target, 'msg:', msg );
    const result = rule(target, msg);
    // debug(`result[${tryToStringify(result)}] rule[${ruleKey}] target[${tryToStringify(target)}] msg[${tryToStringify(msg)}]` );
    return result;
  }

  //Rules for combining things. The first arg is the target, second the message
  //We proceed from the "natural" types to the synthetic types introduced by Simpatico.
  const {UNDEF,NUL,STR,NUM,BOOL,FUN,OBJ,ARR,ELT,ANY,CORE,HANDLER,MSG} = TYPES;
  const rules = {};
  rules[NUL+ANY] = (_,b) => b;

  rules[STR+STR]  = (_,b) => b;
  rules[STR+NUL]  = ()    => '';

  rules[NUM+NUM]  = (a,b) => a + b;
  rules[NUM+STR]  = (_,b) => cast(NUM, b);
  rules[NUM+NUL]  = ()    => 0;

  rules[BOOL+BOOL]= (a,b) => b;
  rules[BOOL+STR] = (_,b) => cast(BOOL, b);
  rules[BOOL+NUL] = (a,_) => !a;

  rules[ARR+ARR]  = (a,b) => a.concat(b);
  rules[ARR+ANY]  = (a,b) => [...a,b];
  rules[ARR+NUL]  = ()    => [];

  rules[FUN+ANY]  = (a,b) => a(b);
  rules[ANY+FUN]  = (a,b) => b(a);

  rules[OBJ+OBJ]  = (a,b) => {
    // B is defensively copied, mutated and returned, not A!
    b = Object.assign({},b);
    for (let prop in a){
      b[prop] = b.hasOwnProperty(prop) ?
        combine(a[prop],b[prop]): //recurse
        a[prop]; 
    }
    return b;
  };

  //handler invocation
  //mutation: core.msgs will get a push,
  //mutation: msg will get an id, time and children
  //mutation: all results will get the id of the parent
  rules[OBJ+MSG] = (core, msg) => { 
    const {UNDEF, ARR, OBJ} = PREDS;

    // World event - defensively copy because we mutate
    if (UNDEF(msg.parent)) msg = Object.assign({}, msg);

    msg.id = core.msgs.length;
    // msg.time = now();
    core.msgs.push(msg);

    //Find the named handler
    const handler = core.handlers[msg.handler];
    if (!handler) throw `handler not found for call ${JSON.stringify(msg)}`;

    // Invoke the handler.
    // Results should always be an array, so help sloppy handlers
    let results = handler[HANDLER](core, msg);
    if (UNDEF(results)) results = [];
    if (!ARR(results))  results = [results];

    // Build up some more info about the message cascade.
    msg.children = results;

    //Recurse for each result
    for (const result of results){
      // Store the id of the parent to avoid cycles that stop stringification
      if (OBJ(result)) result.parent = msg.id;
      core = combine(core, result); //recurse
    }
    return core;
  };

  //handler registration
  rules[OBJ+HANDLER] = (core, handler) => {
    core = combine(core, {handlers:{}, msgs:[]}); 
    core.handlers[handler.name] = handler;
    return core;
  };

  // Convenience functions that wrap combine
  const combineAll = (arr, core={}) => arr.reduce(combine, core)
  const S = (...args) => combineAll(Array.from(args))

  // Tests
  let foo = {name: 'foo', handle: (core, {d}) => [{a:1}, {c:2, d}]}
  let msg = {handler:'foo', d:3};

  let fib = {name:'fib', handle: ({a=1,b=1})=>[{a:b,b:a+b}]};
  let next = {handler:'fib'};









  // S(fib, next, next, next).a;

  // The second part of Simpatico is the Rehman Tree, or RTree.
  // It's an n-array tree with some extras.
  const rtree1 = (rootval = {}, reducer = combine) => {
    let branchIndex = 0;

    const {OBJ, NUM, NUL} = PREDS;
    // mutation: put the branch index into node's value (only if an object)
    if (OBJ(rootval)) rootval.branchIndex = 0;

    const root = {parent: null, val: rootval};

    const nodes = [root];
    const branches = [root];
    const residues = [root.val];

    const branch = () => branches[branchIndex];
    const residue = () => residues[branchIndex];

    const setBranch = a => branchIndex = a;

    /** 
    parent can be 
       a node,
       a pos number (branchIndex), 
       neg number (-nodeIndex)
       null (root node)
    if the node is not the tip of a branch, then a new branch is made
    */
    const add = (val={}, parent=branch()) => {
      if (NUM(parent)) {
        if (parent >= 0){ // select a branch
          assert(parent < branches.length, 
            `invalid positive parent [${parent}] < [${branches.length}]`);
          branchIndex = parent;
          parent = branches[parent];
        } else { // select a node, creating a branch
          assert(parent < nodes.length, 
            `invalid negative parent [${parent}] < [${branches.length}]`);

          parent = nodes[-parent]; //we will be branching
        }
      } else if(NUL(parent)){
        parent = root;
      }
      const node = {parent, val};

      // If the parent is already a branch, then replace parent with the new node
      const i = branches.indexOf(parent);
      if (i !== -1){
        branches[i] = node;
        residues[i] = reducer(residues[i], node.val);
      } else {
        // Otherwise, add a new branch and set the branchIndex
        branchIndex = branches.length; //we will be adding one
        // mutation: put the branch index into the node's value.
        if (OBJ(node.val)) node.val.branchIndex = branchIndex;
        branches.push(node);
        residues.push(computeResidue(node, rootval, reducer)); 
        // Note: because we re-reduce the parent, the user must be careful to branch
        // from a point that doesn't have side-effects.
      }
      nodes.push(node);
      return node; //would be nice to return "this" but I'm not sure how...
    };

    // Return the list of nodes from root to the given node
    const path = (node = branch()) => {
      const result = [node];
      while(node.parent) {
        node = node.parent;
        result.push(node);
      }
      return result.reverse();
    }

    const print = (summarize = identity) => {
      const docs = `0 - 0 1 2 3 8 {}
 1 - 2 4 5 {}
 2 - 4 6 7 {}`
      const nodeIndex = node => nodes.indexOf(node);
      const row = path => path.map(nodeIndex).join(' ');
      const all = branches.map(b=>row(path(b)));
      return all.join('\n');
    }
    // Return all the values
    const values = () => nodes.map(n=>n.val);

    // Return the list of values from root to given node
    const valuePath = (node = branch()) => path(node).map(n => n.val);

    // Residue is the reduction of all values to the given node.
    const computeResidue = (node = branch(), base = {}, reducer = combine) => 
      valuePath(node).reduce(reducer, base);
    
    const computeAllResidues = (base={}, reducer = combine) => 
      branches.map(branch => residue(branch,base,reducer));

    return {add, branch, setBranch, branches, residues, path, values, valuePath, residue, computeAllResidues, nodes, print};
  }

  /*
     This rtree is implemented with arrays.
     The data-structure looks like this:

     0 - 0 1 2 3 8 {}
     1 - 2 4 5 {}
     2 - 4 6 7 {}
     focus: 0 

     The first column is the row number (included for readability)
     The next number is the parent node for the row.
     The next numbers indicate the values in the order they came in.
     The last object is the residue of the row all the way back to root.

     For example, row 1 {} is ∫[0 1 2 4 5], and row 2 {} is ∫[0 1 2 4 6 7]

     The RTree has a mutable state, the focus, which determines what happens on the next add.

    Row focus is just a number. This is the default.
    Branching focus is an array: [row,col] or [node]

    row ={row, parent, values, residue}
  */
  const rtree = (base = {}, reducer = combine) => {
    let foc = 0;

    const values = [];
    const rows = [{row:0, parent: null, values:[], residue: base}];

    const add = value => {
      const i = values.length;
      const branching = PREDS.ARR(foc);
      values.push(value);
      if (!branching){
        const row = rows[foc];
        row.values.push(i);
        row.residue = reducer(row.residue, value);
      } else {
        // The interesting case - we are branching!
        // TODO - decide if supporting columns is actually worth it. This impl is so nice...
        const [rowi, coli] = foc;
        const parentRow = rows[rowi];
        foc = rows.length;
        rows.push({
          row:rows.length, 
          parent: rowi, 
          values:[value], 
          residue: reducer(parentRow.residue, value)
        });
      }
      return print();
    }

    const focus = (a,b) => {
      foc = PREDS.ARR(a) ? foc = a : foc = [a,b];
      return print();
    }

    const residues = () => rows.map(row=>row.residue);

    const printRow = row => `${row.row} - ${row.parent === null ? 'n' : row.parent} ${row.values.join(' ')} [${row.residue}]`;
    const print = ()=> '\n' + rows.map(printRow).join('\n') + `\n focus: ${foc}`;


    return {values, rows, add, focus, residues, print};
  }

  // Basic Tests
  let sum = (a,b) => a+b;
  let t = rtree(0,sum);
  assertEquals(t.residues()[0], 0)
  t.add(1); // default is branch 0
  assertEquals(t.residues()[0], 1)
  t.add(1); 
  assertEquals(t.residues()[0], 2)

  //branch from the root node
  t.focus([0,0])
  t.add(1) 
  assertEquals(t.residues()[0], 2)
  assertEquals(t.residues()[1], 1)
  t.add(1) // add to the branch
  assertEquals(t.residues()[0], 2)
  assertEquals(t.residues()[1], 2)
  t.add(1) // add to the branch
  assertEquals(t.residues()[0], 2)
  assertEquals(t.residues()[1], 3)

  t.add(1,0) // go back to branch 0
  assertEquals(t.residues()[0], 3)
  assertEquals(t.residues()[1], 3)
  t.add(1)
  assertEquals(t.residues()[0], 4)
  assertEquals(t.residues()[1], 3)

  // Branch index tests
  // t = rtree({a:0})
  // assertEquals(t.residues()[0].branchIndex, 0, 'The default branch index is 0')
  // assertEquals(t.residues[0].a, 0)
  // t.add({a:1})
  // assertEquals(t.residues[0].branchIndex, 0, 'The branch index does not change on add')
  // assertEquals(t.residues[0].a, 1)

  // t.add({a:1}, null) //branch from the root node, creating branch 1
  // assertEquals(t.residues[1].branchIndex, 1, 'The new branch gets a new index')
  // assertEquals(t.residues[1].a, 1)
  // assertEquals(t.residues[0].a, 1)

  // t.add({a:1})  // add to branch 1
  // assertEquals(t.residues[0].branchIndex, 0)
  // assertEquals(t.residues[1].branchIndex, 1)
  // assertEquals(t.residues[0].a, 1)
  // assertEquals(t.residues[1].a, 2)

  // t.add({a:1},0) // add to branch 0
  // assertEquals(t.residues[0].branchIndex, 0)
  // assertEquals(t.residues[1].branchIndex, 1)
  // assertEquals(t.residues[0].a, 2)
  // assertEquals(t.residues[1].a, 2)
  // assertEquals(t.nodes.length, 5)

  // t.add({a:1},-t.nodes.length) //branch off the last node






  // With a working RTree we can implement unified inheretence/instantiation.
  // We define a type as a set of handlers
  // We add handlers one at a time, and then branch to create an instance.
  // We can also branch to create a subtype, if the new branch also has handlers.


  // Let's start with a clock.
  t = rtree();
  t.add({
    interval: 1000, limit: 3, //config
    intervalId: null, ticks: 0, err: null, 
    started: null, stopped: null, duration: null
  });

  t.add({name: 'start', handle:(c,m)=>{
    if (c.started) return;
    debug('start', now(), c.branchIndex);

    const intervalId = window.setInterval( 
      () => t.add({handler:'tick'}, c.branchIndex), 
      c.interval
    );

    return [{intervalId}, {started:now()}];
  }});

  t.add({name: 'stop', handle:(c,m)=>{
    if (c.stopped) return;
    window.clearInterval(c.intervalId);
    const stopped = now();
    return [{stopped},{duration:stopped-c.started}];
  }});

  t.add({name: 'tick', handle:(c,m)=>{
    debug('tick', c.ticks, c.limit, c.intervalId, c.branchIndex);
    return (c.ticks < c.limit) ? {ticks:1} : {handler:'stop'};
  }});

  let branchPoint = t.nodes.length-1;
  t.add({handler:'start'}, -branchPoint);

  // t.add({handler:'start'});

  // t.add({handler:'start'}) t.residue()


	// This is a clock that runs for a finite time
	// It is very short and expects the user to know what they are doing, 
	// I have opted to NOT make the clock immutable, but some mutations will
	// obviously break things; you'll need to restart your browser.
	// let clock = {
	// 	interval: 17, limit: 1, //config
	// 	intervalId: null, ticks: 0, err: null, 
	// 	started: null, stopped: null, duration: null,

	// 	tickHandlers: [ //side-effects with double duty as predicates
	// 		ctx => ctx.ticks++ || true,
	// 		ctx => ctx.ticks < ctx.limit,
	// 		// ctx => log(ctx.ticks) || true,
	// 		// ctx => document.getElementById('square').setAttribute('transform', 
	// 		// 	`scale(${ctx.ticks/100},${ctx.ticks/100})rotate(${ctx.ticks/1})`
	// 		// 	) || true,
	// 	],

	// 	_ontick: (ctx) => { 
	// 		let checks = ctx.tickHandlers.map(fn => fn(ctx));
	// 		debug(checks);
	// 		if (!all(checks)) ctx.cancel(ctx);
	// 	},

	// 	// TODO Write a version that pumps using this.
	// 	start2 :  (ctx) => {
	// 		window.requestAnimationFrame(()=>clock._ontick(ctx));
	// 	},

	// 	start	: (ctx) => {
	// 		assert(ctx, 'You start a clock with an instance via clock.start(clock)');
	// 		ctx.intervalId = window.setInterval(()=>ctx._ontick(ctx), ctx.interval);
	// 		ctx.started = now();
	// 		return ctx;
	// 	},
	// 	cancel	: (ctx) => {
	// 		assert(ctx, 'You cancel a clock with an instance via clock.cancel(clock)');
	// 		window.clearInterval(ctx.intervalId);
	// 		ctx.stopped = now();
	// 		ctx.duration = ctx.stopped - ctx.started; //dependent data!
	// 		return ctx;
	// 	},
	// 	reset 	: (ctx) => {
	// 		assert(ctx, 'You reset a clock with an instance via clock.reset(clock)');
	// 		ctx.intervalId = null;
	// 		ctx.ticks = 0; ctx.err = null; ctx.started = null; ctx.stopped = null;
	// 		return ctx;
	// 	},
	// };

	// clock.start(clock);

	// Sadly, for animation this isn't good enough. We don't get good enough guarantees
	// out of the setInterval; for that we want a requestAnimationFrame() pump. 
	// Does that consume stack space? 

	// Sub-resources, fetch/XHR, WebSockets and WebRTC are all ways to get network input
	// All require client initiated action, and only the last two leave a connection in place.



</script>
</body>
</html>
