<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="keywords" content="Simpatico, rtree, es6">
  <meta name="author" content="jbr">

  <!-- Begin testable.js html boilerplate; testable.js is in the same directory -->
  <link id="favicon" rel="icon" type="image/svg+xml" href="data:image/svg+xml,
    <svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1 1'>
        <rect width='1' height='1' fill='white' />
    </svg>"/>
  <meta id="refresh" http-equiv="refresh" content="2">
  <script src="testable.js" type="module"></script>
  <!-- End testable.js boilerplate  -->

  <title>SimpatiCode: combine() and buildTree()</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
<div id="content">
  <h1>SimpatiCode: combine() and buildTree()</h1>
  <p>javajosh <i>(c) 2023</i></p>
  <div class="makeItStop"></div>
  <p>See <a href="./combine2.md">design notes</a></p>
</div>

<script type="module">
  import {assertEquals, mapObject} from './core.js';
  import {combine, stree as buildTree, assertHandler} from './combine2.js';

  let DEBUG = false;

  // Some test fixture handlers
  const log = {
    handle: (...args) => {
      if (DEBUG) console.log(args);
      return [{}];
    }
  };
  const inc = {handle: ()            => [{a: 1}, {b: 2}]};
  const sum = {handle: (_, {a, b})   => [{a: a + b}]};
  const mul = {handle: ({a}, {a: b}) => [{a: null}, {a: a * b}]};

  testCombineDataLanguage();
  testBasicHandlerExecution();
  testAssertionHandler();
  testHandlerRedefinition();
  testTreeInternals();
  testTreeAssertions();
  testTreeHandlers();
  testNeuTypeVersioning();
  // testOpsSerialization();

  // Exercise basic UDL (universal data language) semantics, specifically omitting handlers.
  function testCombineDataLanguage() {
    // Noops
    assertEquals({a: [1, 3, {b: 1}]}, combine({a: [1, 3, {b: 1}]}, undefined));
    assertEquals({a: [1, 3, {b: 1}]}, combine({a: [1, 3, {b: 1}]}, {}));

    // Zeroing out objects and arrays with null
    assertEquals({}, combine({a: [1, 3, {b: 1}]}, null))
    assertEquals({a: []}, combine({a: [1, 3, {b: 1}]}, {a: null}))

    // Boolean has an alternating behavior with null - let's test it.
    assertEquals(true, combine(false, null));
    assertEquals(false, combine(true, null));
    assertEquals(true, combine(false, true));
    assertEquals(false, combine(true, false));

    // Strings replace
    assertEquals('', combine('anything', null));
    assertEquals('b', combine('a', 'b'));

    // Numbers add
    assertEquals(3, combine(1, 2));

    // Combine each element of an array
    assertEquals({a: [2, 3, 4]}, combine({a: [1, 3, 4]}, {a: [1]}));
    assertEquals({a: [2, 3, {b: 2}], c: false}, combine({a: [1, 3, {b: 1}]}, {a: [1, 0, {b: 1}], c: false}))
  }

  // Create a (very contrived) core from handlers and run it through a list of mutations and assertions
  // Still using assertEquals outside the core instead of assertion handlers.
  function testBasicHandlerExecution() {
    // We can test handlers on their own, as simple pure functions:
    assertEquals([{}], log.handle(1, 2));
    assertEquals([{a: 1}, {b: 2}], inc.handle());
    assertEquals([{a: 5}], sum.handle({}, {a: 2, b: 3}));
    assertEquals([{a: null}, {a: 6}], mul.handle({a: 2}, {a: 3}));
  }

  function testAssertionHandler(){
    // We use these handlers to form a "core" and treat input as a monotonic sequence of object additions.
    let core = {handlers: {log, inc, sum, mul, assert: assertHandler}};

    // A simple case: all handlers are available all the time and can be called in any order.
    const ops = [
      {handler: 'log'},
      {handler: 'inc'},
      {handler: 'assert', a: 1, b: 2},
      {handler: 'inc'},
      {handler: 'assert', a: 2, b: 4},
      {a: null},
      {handler: 'assert', a: 0},
      {handler: 'sum', a: 1, b: 2},
      {handler: 'assert', a: 3},
      {a: null},
      {a: 2},
      {a: 2},
      {handler: 'assert', a: 4},
      {handler: 'mul', a: 10},
      {handler: 'assert', a: 40},
      {handler: 'log'},
    ];
    ops.every(op => core = combine(core, op));
  }

  function testHandlerRedefinition(){
    // We use these handlers to form a "core" and treat input as a monotonic sequence of object additions.
    let core = {handlers: {log, inc, sum, mul, assert: assertHandler}};

    // A simple case: all handlers are available all the time and can be called in any order.
    const ops = [
      {handler: 'log'},
      {handler: 'inc'},
      {handler: 'assert', a: 1, b: 2},
      {handler: 'inc'},
      {handler: 'assert', a: 2, b: 4},
      {a: null},
      {handler: 'assert', a: 0},
      {handler: 'sum', a: 1, b: 2},
      {handler: 'assert', a: 3},
      {a: null},
      {a: 2},
      {a: 2},
      {handler: 'assert', a: 4},
      {handler: 'mul', a: 10},
      {handler: 'assert', a: 40},
      {handler: 'log'},
    ];
    ops.every(op => core = combine(core, op));
  }

  function testTreeInternals() {
    // 2: Now lets experiment with adding integers to the operations list, forming a trie
    const o = {};
    const a1 = {a: 1};
    const a2 = {a: 2};
    const a3 = {a: 3};
    const a4 = {a: 4};
    const a5 = {a: 5};
    const a6 = {a: 6};

    const ops2 = [
      o, a1, a2,
      0, a3, a4,
      2, a5,
      -1, a6
    ];
    const {nodes, rows, branches} = buildTree(ops2);
    assertEquals([o, a1, a2, a3, a4, a5, a6], nodes);
    assertEquals([
      [o, a1, a2],
      [0, a3, a4, a6],
      [2, a5]
    ], rows);
    assertEquals([
      [o, a1, a2],
      [o, a3, a4, a6],
      [o, a1, a2, a5]
    ], branches());
  }

  function testTreeAssertions() {
    // 3: Same as ops but with more interspersed integers
    const ops3 = [
      {handler: 'log'},
      {handler: 'inc'},
      {handler: 'assert', a: 1, b: 2},
      {handler: 'inc'},
      {handler: 'assert', a: 2, b: 4},
      2,
      {a: null},
      {handler: 'assert', a: 0},
      {handler: 'sum', a: 1, b: 2},
      {handler: 'assert', a: 3},
      {a: null},
      {a: 3},
      {a: 2},
      {handler: 'assert', a: 5},
      {handler: 'mul', a: 10},
      {handler: 'assert', a: 50},
      {handler: 'log'},
    ];
    const {branches: branches3, allBranchesReachable, residues, summary} = buildTree(ops3);
    allBranchesReachable({handlers: {log, inc, sum, mul, assert: assertHandler}});
    if (DEBUG) console.log('branches3()', branches3(), 'residues', residues, 'summary', summary);
  }

  // (Re) building out an example of classic OOP types and instantiation with Simpatico
  function testTreeHandlers() {
    const h1 = {handle: (b, a) => [{a: null}, {a: a * 1}], example: {handler: 'h1', a: 2}};
    const h2 = {handle: (b, a) => [{a: null}, {a: a * 2}], example: {handler: 'h2', a: 2}};
    const h3 = {handle: (b, a) => [{a: null}, {a: a * 3}], example: {handler: 'h3', a: 2}};
    const h4 = {handle: (b, a) => [{a: null}, {a: a * 4}], example: {handler: 'h4', a: 2}};

    // helper functions to build the ops (and a few tests to exercise/explain the intended use as authoring tools
    const h = a => [0, h1, h2, h3, h4][a].example;
    const a = a => ({a});
    const b = b => ({b});
    const as = a => ({handler: 'assert', ...a});
    assertEquals({handler: 'h1', a: 2}, h(1));
    assertEquals({handler: 'h3', a: 2}, h(3));
    assertEquals({handler: 'h4', a: 2}, h(4));
    assertEquals({a: 2}, a(2));
    assertEquals({handler: 'assert', a: 7}, as({a: 7}));

    // In this case we're building up a simple type tree and instantiating some of the types (and asserting things)
    const ops = [
      {handlers: {assert: assertHandler}},
      0, {type: 'foo'}, {handlers: {h1, h2}}, // 2
      0, {type: 'bar'}, {handlers: {h3}}, {handlers: {h4}}, // 5; note the split handlers
      0, {type: 'baz'}, {handlers: {h3, h4}}, // 7
      2, a(1), as({a: 1}), a(2), as({type: 'foo', a: 3}), a(5), as({a: 8}),
      5, a(3), as({type: 'bar', a: 3}), // h(3), as({a:7}),
      7, a(4), as({type: 'baz', a: 4}),
    ];
    const {add, neu, residues, summary, nodes, allBranchesReachable} = buildTree(ops);
    allBranchesReachable({});
    console.log('residues', residues, 'nodes', nodes, 'summary', summary);
  }

  function testNeuTypeVersioning(){
    // todo: demonstrate type versioning; explore a way to avoid calculating node offsets for instance rows.
    // a reasonable desire would be to target a type by row and create a new instance based on the current type length
    // this messes up the general authoring, but if you limit yourself to only instantiating after the type rows, it can be done!
    // We add special logic into the tree "add" method that does something special if a type row.
    // This in turn requires a relatively fast residue computation.
    if (true) return;
    assertEquals(7, residues.length);
    assertEquals(1, neu(-1));
    assertEquals(8, residues.length);
    assertEquals('foo', peek(residues).type);
    console.log(peek(residues));

    assertEquals(2, neu(-2));
    assertEquals(9, residues.length);
    assertEquals('bar', peek(residues).type);

    assertEquals(1, neu('foo'));
    assertEquals(10, residues.length);
    assertEquals('foo', peek(residues).type);
    assertEquals(2, peek(residues).version);

    // Demonstrate type-versioning. Modify the handler,
    add(-1);
    add({handlers: {h1: {handle: a => [{a: null}, {a: a * 3}]}}});
    assertEquals(1, neu('foo'));
    assertEquals(11, residues.length);
    assertEquals('foo', peek(residues).type);
    assertEquals(22, peek(residues).version);
    assertEquals(10, peek(residues).rowId);
    add(-10);
    add({handler: 'h1', a: 2});
    // assertEquals(4, peek(residues).a);
  }

  // For some reason now is the time to play with function de/serialization.
  function testOpsSerialization(){
    const serializeHandler = a => {
      a.handle = a.handle.toString();
      return a;
    }
    const deserializeHandler = a => {
      // We can and should do some more validation and checking, perhaps limit length, for security purposes.
      a.handle = eval(a.handle);
      return a;
    }
    const h6 = {handle: '(a, b) => 42'};
    const h7 = {handle: (a, b) => 42};
    assertEquals(h6.handle, h7.handle.toString());
    assertEquals(h6, serializeHandler(h7))
    assertEquals(h7.handle.toString(), deserializeHandler(h6).handle.toString());

    const serializeOps = ops => {
      // This is awful, I should use map() and not mutate with delete,
      ops.every(op => {
        if (!isObj(op)) return;
        delete op[parent];
        if (isCore(op))
          op.handlers = mapObject(op.handlers, ([k, v]) => [k, serializeHandler(v)])
        return true;
      });
      return ops;
    };

    const deserializeOps = ops => {
      ops.every(op => {
        if (isCore(op))
          // This is awful, I should use map() and not mutate with reassignment,
          op.handlers = mapObject(op.handlers, ([k, v]) => [k, deserializeHandler(v)])
      });
      return ops;
    };
    assertEquals([], serializeOps([]));
    assertEquals([a(1)], serializeOps([a(1)]));
    // assertEquals([{handlers: {h6: h6.toString()}}], serializeOps([{handlers: {h6: h7.toString()}}]));
    // assertEquals([{handlers: {h7}}], deserializeOps([{handlers: {h6}}]));
  }
  </script>
</body>
</html>
