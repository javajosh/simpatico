<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="keywords" content="JavaScript, ES6, functional, simpatico, minimalist, web verite">
  <meta name="author" content="javajosh">
  <link id="favicon" rel="icon" type="image/png" href="img/wizard-192x192.png"/>

  <title>websockets</title>
  <link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
<h1>Simpatico</h1>
<p>javajosh <i>2023</i></p>

<p>
  This is a very tiny chat system that demonstrates raw websockets in the browser.
</p>

<h3>Messages</h3>
<ol id="display-chat">
  <li><label>Say something:<input type="text"></label></li>
</ol>

<script type="module">
  import * as wcb from './webcryptobox.js';

  const DEBUG = false;
  const DURABLE_KEY = 'durable-process';
  const displayChat = document.getElementById('display-chat');
  const ls = window.localStorage;


  // Initialize either by restoring a keypair or generating a new one.
  const {keyPair, keyPairPem} = await initializeDurableProcess(DURABLE_KEY);

  // Connect to the reflector over websockets
  const websocketURL = window.location.toString().replace(/^http/, 'ws');
  const connection = connect(websocketURL, keyPair, keyPairPem, e => {
    addListItem(e.data);
  });


  async function initializeDurableProcess(key=DURABLE_KEY) {
    let keyPair, keyPairPem;
    // useful for debugging: ls.removeItem(key);
    if (!ls.hasOwnProperty(key)) {
      // Generate a new keypair
      keyPair = await wcb.generateKeyPair();
      keyPairPem = {
        publicKeyPem:  await wcb.exportPublicKeyPem(keyPair.publicKey),
        privateKeyPem: await wcb.exportPrivateKeyPem(keyPair.privateKey)
      };
      ls.setItem(key, JSON.stringify(keyPairPem));
      if (DEBUG) console.log('created durable-process keypair in localStorage', keyPairPem, keyPair);
    } else {
      try{
        const keyPairString = ls.getItem(key);
        keyPairPem = JSON.parse(keyPairString);
        keyPair = {
          publicKey: await wcb.importPublicKeyPem(keyPairPem.publicKeyPem),
          privateKey: await wcb.importPrivateKeyPem(keyPairPem.privateKeyPem)
        };
        if (DEBUG) console.log('recovered durable-process keypair from localStorage', keyPairPem, keyPair);
      } catch (e) {
        console.error('invalid keys, deleting and start again');
        ls.removeItem(key);
        throw e;
      }
    }
    return {keyPair, keyPairPem};
  }

  // Read: Open the socket and become capable of sending and recieving messages
  function connect (url, keyPair={}, keyPairPem={}, handler) {
    const conn = new WebSocket(url);
    conn.onopen = () => {
      conn.send(keyPairPem.publicKeyPem);
      document.body.onchange = onWrite;
    }
    conn.onmessage = handler;
    return conn;
  }

  // Display a string as a new list element
  function addListItem (itemHtml, parent = displayChat) {
    const li = document.createElement("li");
    li.innerHTML = itemHtml;
    parent.appendChild(li);
    if (DEBUG) console.debug(`itemHtml received and appended as li [${itemHtml}]`);
  }

  function isConnReady (conn = connection) {
    return conn !== undefined && conn.readyState === conn.OPEN
  }

  // Write: User input is received. Route outbound messages from the DOM to the connection.
  // if the connection is down, try to reestablish.
  // if the connection is up, send the target.value as a string.
  function onWrite(e) {
    try {
      if (!isConnReady()){
        if (DEBUG) console.log('connection down attempting reconnect', url);
        connection = connect(url); // need a backoff timer to avoid floods in more complex cases.
      } else {
        const msg = e.target.value;
        connection.send(msg);
        if (DEBUG) console.debug(`msg sent ${msg}`);
      }
    } catch (e) {
      console.error('problem processing change input');
      throw e;
    }
    return false;
  }
</script>
</body>
</html>
