<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="keywords" content="JavaScript, ES6, functional, simpatico, minimalist, web verite">
  <meta name="author" content="javajosh">
  <link id="favicon" rel="icon" type="image/png" href="img/wizard-192x192.png"/>

  <title>websockets</title>
  <link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
<h1>Chat</h1>
<p>javajosh <i>2023</i></p>

<p>
  This is a very tiny chat system that demonstrates raw websockets in the browser.
  <button id="reset-button">Reset keypair</button>
</p>

<h3>Messages</h3>
<ol id="display-chat">
  <li><label>Say something:<input type="text"></label></li>
</ol>

<script type="module">
  import * as wcb from './webcryptobox.js';

  const DEBUG = false;
  const DP_LOCAL_STORAGE_KEY = 'durable-process';
  const body = document.body;
  const displayChat = document.getElementById('display-chat');
  const resetButton = document.getElementById('reset-button');
  const websocketURL = window.location.toString().replace(/^http/, 'ws');
  const ls = window.localStorage;

  // Initialize either by restoring a keypair or generating a new one.
  const {keyPair, keyPairPem} = await initializeDurableProcess(DP_LOCAL_STORAGE_KEY);

  // Start the connection, register a listener/msg handler
  // TODO: connection may be lost and recreated.
  let connection = connect(websocketURL, keyPair, keyPairPem, e => receiveMessage(e.data));

  // Turn body change events (emitted by form fields) into msg sends.
  body.addEventListener('change', e =>  {
    sendMessage(e.target.value);
    e.target.value = "";
  });

  // A click deletes the old keys, make new ones, and refreshes the page.
  resetButton.addEventListener('click', () => {
    initializeDurableProcess(DP_LOCAL_STORAGE_KEY, true);
    window.location.reload();
    return false;
  });

  // ==============================================================
  // Begin support functions:
  async function initializeDurableProcess(key=DP_LOCAL_STORAGE_KEY, resetKeys = false) {
    let keyPair, keyPairPem;
    if (resetKeys) ls.removeItem(key);
    if (!ls.hasOwnProperty(key)) {
      // Generate a new keypair
      keyPair = await wcb.generateKeyPair();
      keyPairPem = {
        publicKeyPem:  await wcb.exportPublicKeyPem(keyPair.publicKey),
        privateKeyPem: await wcb.exportPrivateKeyPem(keyPair.privateKey)
      };
      ls.setItem(key, JSON.stringify(keyPairPem));
      if (DEBUG) console.log('created durable-process keypair in localStorage', keyPairPem, keyPair);
    } else {
      try{
        const keyPairString = ls.getItem(key);
        keyPairPem = JSON.parse(keyPairString);
        keyPair = {
          publicKey: await wcb.importPublicKeyPem(keyPairPem.publicKeyPem),
          privateKey: await wcb.importPrivateKeyPem(keyPairPem.privateKeyPem)
        };
        if (DEBUG) console.log('recovered durable-process keypair from localStorage', keyPairPem, keyPair);
      } catch (e) {
        console.error('invalid keys, deleting and start again');
        ls.removeItem(key);
        throw e;
      }
    }
    return {keyPair, keyPairPem};
  }

  // Read: Open the socket and) become capable of sending and recieving messages
  function connect (url, keyPair, keyPairPem, handler) {
    const conn = new WebSocket(url);
    conn.onopen = () => {
      sendMessage(keyPairPem.publicKeyPem, conn);
    }
    conn.onmessage = handler;
    return conn;
  }

  // Display a string as a new list element
  function addListItem (itemHtml, parent = displayChat) {
    const li = document.createElement("li");
    li.innerHTML = itemHtml;
    parent.appendChild(li);
    if (DEBUG) console.debug(`itemHtml received and appended as li [${itemHtml}]`);
  }

  function isConnReady (conn = connection) {
    return (conn !== undefined) && (conn.readyState === conn.OPEN);
  }

  // Send a message over the websocket, reconnecting if necessary.
  function sendMessage(msg, conn = connection) {
    if (!isConnReady(conn)) throw 'connection is not ready';
    try {
      conn.send(msg);
      if (DEBUG) console.debug(`msg sent ${msg}`);
      return conn;
    } catch (ex) {
      console.error('problem sending message');
      throw ex;
    }
  }
  function receiveMessage(msg) {
    addListItem(msg);
  }

</script>
</body>
</html>
