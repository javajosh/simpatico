<!DOCTYPE html>
<html>
<head>
  <title>Simpatico - Data Modelling</title>
  <link rel="stylesheet" type="text/css" href="style.css">
  <script src="./d3.v5.js"></script>
</head>
<body>
  <h1>Simpatico - Data Modelling</h1>
  <p>
    Here is a simple data model of a person:
  </p>
  <code>
    <pre>
  {
    name: 'Josh',
    age: 43,
    alive: true,
    job: 'programmer',
    updated: 1534400631722
  }
    </pre>
  </code>
  
  <p>
    Over time, small adjustments are made. In SQL these would be <code>UPDATE</code> statements. In JavaScript, they would probably be mutating dot statements or perhaps a slightly more sophisticated <code>Object.assign</code> call.
  </p>

  <p>
    There is a better way. We can <code>combine()</code> a mutation with a target, in a generalization of Object.assign that better uses the values in the target object. It is mutating, but reversible, so that if a problem occurs you can at least get back to your starting point. (In fact, one of th emore exciting things we can do is define function invocation as a special case of combine. We'll see that in a second.)
  </p>

  


  <p>
    Topics:
  </p>

  <ol>
    <li>Stateful programs</li>
    <li>Durable process</li>
    <li>One communication primitive: Synchronization</li>
    <li>Object patterns and collapse</li>
    <li>Friendly functions</li>
    <li>Handlers</li>
    <li>Message cascade</li>
    <li>World Event Tree</li>
    <li>Stateless cluster</li>
    <li>Simpatico written as 4 reductions</li>

  </ol>

  <script>
    // Define the top-level shape of the application
    function getHandler(combine, render){
      let state = {input:[]};
      return event => {
        state = combine(state, event);
        render(state);
      }
    }

    // Feed events into a handler function
    function connectEvents(handler){
      window.onresize = handler;
      window.onkeyup = handler;
      window.onmousemove = handler;
      window.onmousewheel = handler;
      window.onmousedown = handler;
      window.onmouseup = handler;
    }

    // Combine an event with application state, return a state.
    function combine(state, event){
      state.input.push(event);
      return state;
    }

    // Render application state; use stateful references
    const w = 10, h = 10;
    const color = d3.scaleOrdinal(d3.schemeCategory10);
    const svg = d3.select('svg');

    function render(state){
      const {width, height} = svg.node().getBoundingClientRect();
      const cols = Math.floor(width/w);
      const rows = Math.ceil(height/h);
      console.log(state, width, height);
      svg
        .selectAll('rect')
        .data(state.input)
        .enter().append('rect')
          .attr("x", (d,i) => (i % cols) * w)
          .attr("y", (d,i) => (Math.floor(i / cols)) * h)
          .attr("fill", (d,i) => color(i))
          .attr("width", w)
          .attr("height", h)
          // .attr("stroke", "#000")
          // .attr("stroke-width", 1.0)
    }

    // Start the application by combining 4 functions together.
    connectEvents(getHandler(combine, render));
  </script>
</body>
</html>