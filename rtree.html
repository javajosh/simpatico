<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="keywords" content="Simpatico, rtree, es6">
  <meta name="author" content="Josh Rehman">

  <link id="favicon" rel="icon" type="image/png" href="./img/white.png"/>
  <meta id="refresh" http-equiv="refresh" content="2">
  <script type="module" src="testable.js"></script>

  <title>RTree.js</title>
  <link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
<h1>RTree.js</h1>
<p>Josh Rehman <i>July 2020</i></p>
<button onclick="window.stop()">Stop 2s Refresh</button>

<h2>The Problem of State Management</h2>

<p>The problem of process state management is currently tackled by software components like Redux.</p>

<p>Note that server side software doesn't have state; or rather, it's state is a very tightly coupled to the static
  source code. That type of code is dominated by the definition of singletons (and the reuse of them), to support,
  ultimately, Controllers that do the work. In general, a server must be responsible for its own security.
</p>

<p>These singletons recapitulate many of the same concerns that arise in build systems; in fact its the same concern but
  handled at compile time by one tool (Maven) and at runtime by another tool (Spring). Or on the client by one tool at
  compile-time (npm, ng) and another at runtime (angular module annotations). </p>

<p>The natural data-structure then would be to model state as a special dynamic part of the head of a linked list of
  input. It doesn't really have to be dynamic. </p>

<p>Well, it's a kind of tree that is built up in a particular way. It's a constrained kind of n-arry tree, which is
  optimized for long runs. We imagine the tree composed of rows, and each row has a parent, rather than each node.
  Moreover, we introduce a special coordinate system that supports rows and nodes as parents, and provide a (stateful)
  pointer to the target. The rule is that if you're pointing at a node, you create a new row with that as it's parent.
  Otherwise, you're just adding to the row.</p>

<!--
/**
 This rtree is implemented with arrays.
 The data-structure looks like this:

 0 - 0 1 2 3 8 {}
 1 - 2 4 5 {}
 2 - 6 7 {}
 focus: 0

 The first column is the row number (included for readability)
 The next number is the parent node for the row.
 The next numbers indicate the values in the order they came in.
 The last object is the residue of the row all the way back to root.

 For example, row 1 {} is ∫[0 1 2 4 5], and row 2 {} is ∫[0 1 2 6 7]

 The RTree has a mutable state, the focus, which determines what happens on the next add.

 The focus can be on any node, using its index "i". Note that this implies that focus and input events happen in a set order, on the same timeline. We could make an arbitrary distinction between strings and numbers, and imagine a single timeline in which they are interleaved, giving rise to a peculiar, but quite compact (and useful) representation of a Tree. In this sense it can be seen as a reduction, or a folding of a list that looks like (a, b, c, 0, d, e, 1, f...) into something that looks like:

 Which in turn represents a tree with 3 branches.

 abc
 ade
 bf

 (One clever thing to do (possibly too clever!) is to target either an index or a row by using the negative coordinates to correspond to rows. This would make a very compact focus interface, 2D that takes only 1 integer!)

 Row focus is just a number. This is the default.
 Branching focus is an array: [row,col] or [node]

 row ={row, parent, values, residue}

 */
-->

<script type="module">
  import {assertEquals} from './core.js';
  import rtree from './rtree.js';

  // A very simple RTree using integers as inputs and "add" instead of combine.
  const r = rtree(0);
  assertEquals(r.branches.length, 1);
  assertEquals(r.branches[0].residue, 0);
  assertEquals(r.getFocus(), 0);
  assertEquals(r.residue(), 0);

  // The zeroeth row is now 1
  r.add(1);
  assertEquals(r.branches.length, 1);
  assertEquals(r.branches[0].residue, 1);
  assertEquals(r.getFocus(), 0);
  assertEquals(r.residue(), 1);

  // The zeroeth row is now 4
  r.add(3);
  assertEquals(r.branches.length, 1);
  assertEquals(r.branches[0].residue, 4);
  assertEquals(r.getFocus(), 0);
  assertEquals(r.residue(), 4);

  // Setting focus to node 1, with value 1, does not create a branch, and does not affect the existing branch.
  // The residue at that node is 1
  r.setFocus(1);
  assertEquals(r.branches.length, 1);
  assertEquals(r.branches[0].residue, 4);
  assertEquals(r.getFocus(), 1);
  assertEquals(r.residue(), 1);

  // Adding to a node will create a new branch with value 6. Rows are labeled with negative integers.
  r.add(5);
  assertEquals(r.branches.length, 2);
  assertEquals(r.branches[0].residue, 4);
  assertEquals(r.branches[1].residue, 6);
  assertEquals(r.getFocus(), -1);
  assertEquals(r.residue(), 6);

  r.add(5)
  assertEquals(r.branches.length, 2);
  assertEquals(r.branches[0].residue, 4);
  assertEquals(r.branches[1].residue, 11);
  assertEquals(r.getFocus(), -1);
  assertEquals(r.residue(), 11);

  // Focusing on second node in first row of value 3 and residue 4.
  // Creates a new row
  r.setFocus(2);
  r.add(3);
  assertEquals(r.branches.length, 3);
  assertEquals(r.branches[0].residue, 4);
  assertEquals(r.branches[1].residue, 11);
  assertEquals(r.branches[2].residue, 7);
  assertEquals(r.getFocus(), -2);
  assertEquals(r.residue(), 7);

  // Now an rtree with objects
  const s = rtree()
  assertEquals(s.branches.length, 1)
  assertEquals(s.branches[0].residue, {})
  assertEquals(s.getFocus(), 0)
  assertEquals(s.residue(), {})

  s.add({a:1})
  assertEquals(s.branches.length, 1)
  assertEquals(s.branches[0].residue, {a:1})
  assertEquals(s.getFocus(), 0)
  assertEquals(s.residue(), {a:1})

</script>

<script type="module">
  import latch from './demos/demo-latch.js'
  import {assertEquals, assertThrows, log} from "./core.js";

  log('start', latch.residue().count)
  latch.add({count: -10})
  assertEquals(latch.residue().count, 90)
  latch.add({msg: 'dec'})
  assertEquals(latch.residue().count,89)
  latch.add({msg: 'dec', amount:10})
  assertEquals(latch.residue().count, 79)
  latch.add({msg: 'dec', amount:79})
  assertEquals(latch.residue().count, 0)
  assertThrows( ()=>latch.add({msg: 'dec'}))

  // latch.add({msg: 'dec', amount: 5}, r => assertEquals(r.count, 94));
  // latch.add({msg: 'dec', amount: 50},r => assertEquals(r.err.failures, {amount:['between', 0, 10]}));

</script>
</body>
</html>
