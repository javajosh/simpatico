<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
	<script>
		// We can check for ES6 support like this
		window.onerror = function(e) {
			console.log('Hmm something is wrong with the script!', e.toString());
			return false; // return true to suppress console error. 
		};
	</script>

	<script>
// run parser (automatic)
// syntax errors will halt execution of the entire script block.
// i wonder if this applies to modules, too?
'use strict';

// define an optional type
const num = a => {if (typeof a !== 'number') throw new Error(`${a} expected to be of type number but was of type ${typeof a}`); return a};

//define application modules (pure functions, in this case)
const add = (a,b) => num(a) + num(b);
const mul = (a,b) => num(a) * num(b);

//define tests
function test(){
  // define test helpers
  const assert = (a, msg) => {if (!a) throw new Error(msg)};
  const equals = (a, b) => assert(a===b, `${a} not equal to ${b}`);
  const throws = fn => {let a = false; try{fn()} catch(e){a=true};assert(a, 'fn did not throw')};
  // define & run module/unit tests
  equals(2+3, add(2,3));
  equals(2*3, mul(2,3));
  throws(()=>add(1,''));
  throws(()=>mul(null,4));
  // missing application test!
  // missing edge cases, like overflow!
}

// define the application
function app(){
  console.log('add', 'mul', add(2,3), mul(2,3));
  // add = 1; //assignment to constant var
  // add = bar; //bar is not defined.
}

// run the tests
test();

// run the app
try{
  app();
} catch(e) {
	// this catches es6 and use strict violations!
  window.alert(`I'm sorry there was a problem! ${e.message}`);
}

	</script>
</body>
</html>