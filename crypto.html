<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="keywords" content="JavaScript, ES6, functional, simpatico, minimalist, web verite">
  <meta name="author" content="javajosh">

  <!-- Begin testable.js html boilerplate; testable.js is in the same directory -->
  <link id="favicon" rel="icon" type="image/svg+xml" href="data:image/svg+xml,
  <svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1 1'>
      <rect width='1' height='1' fill='white' />
  </svg>"/>
  <meta id="refresh" http-equiv="refresh" content="2">
  <script src="/testable.js" type="module"></script>
  <!-- End testable.js boilerplate  -->

  <title>crypto</title>
  <link rel="stylesheet" href="/style.css">
</head>
<body>
<h1>crypto</h1>
<p>javajosh <i>2023</i></p>
<div class="makeItStop"></div>

<h2>Encrypt/Decrypt</h2>
<p>
  Exercise cryptographic primitives.
  In this case use the crypto library to generate a key, encrypt a thing, then decrypt.
  Note that, at this point, we cannot save the generated keys for later use.
  This is enough to save ciphertext and later decrypt it.
  References:
</p>
<ol>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/generateKey">MDN's generateKey() docs</a></li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/exportKey">MDN's exportKey() docs</a></li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey">MDN's importKey() docs</a></li>
  <li><a href="https://w3c.github.io/webcrypto/#dfn-SubtleCrypto-method-generateKey">See the w3c web crypto spec</a></li>
  <li><a href="https://www.crypto101.io/">Crypto 101 is a good intro text to the field.</a></li>
</ol>


<script type="module">
  import {assertEquals, log, assert} from './core.js';
  import {generateSymmetricKey, encrypt, pack, decrypt, unpack, equalBuffers} from './crypto.js';

  // encrypt message
  const msg = 'Hey crypto cats!!';
  log('initializing', msg);
  const key = await generateSymmetricKey();
  log('generated key', key);
  const { cipherText, iv } = await encrypt(msg, key);
  log('encrypted message', {cipherText, iv});

  // await fetch('/secure-api', {
  //   method: 'POST',
  //   body: JSON.stringify({
  //     cipher: pack(cipher),
  //     iv: pack(iv),
  //   }),
  // })
  // const response = await fetch('/secure-api').then(res => res.json())

  const fakeResponse = {
    cipherText: pack(cipherText),
    iv: pack(iv),
  };

  const unpacked = {
    cipherText: unpack(fakeResponse.cipherText),
    iv: unpack(fakeResponse.iv),
  }
  log('fakeResponse', fakeResponse, 'unpacked', unpacked);
  assertEquals(unpacked.cipherText, cipherText);
  assert(equalBuffers(unpacked.iv, iv));

  // unpack and decrypt message
  const final = await decrypt(
    {cipherText, iv},
    key,
  );
  log('decrypted message', final);
  assertEquals(final, msg);
</script>

<h2>Export keys</h2>
<p>
  Export by picking a format and calling exportKey
  Format support depends on the type of underlying key.
  I believe that 'raw' is universally supported, however.
</p>

<script type="module">
  import {generateIv, generateSymmetricKey, importSymmetricKey, pack, encrypt, decrypt} from './crypto.js';
  import {log, mapObject, getProp} from './core.js';

  //Make a key and encrypt something with it
  const key = await generateSymmetricKey();
  const { cipherText, iv } = await encrypt("hello!", key);

  // How to remove a key?

  // Export the key in raw; check what is supported with checkSupportedKeyExportFormats()
  let exportedKey = await window.crypto.subtle.exportKey('raw', key);
  const exportedKeyPacked = pack(exportedKey);
  log(exportedKey, exportedKeyPacked);


  // Import the key. The signature is:
  // importKey(format, keyData, algorithm, extractable, keyUsages)
  const key2 = await window.crypto.subtle.importKey(
    'raw',
    exportedKey,
    {
      name: 'AES-GCM',
      iv,
    },
    true,
    ['encrypt', 'decrypt']
  );

  // Now we can use the key again!
  const final = await decrypt(
    {cipherText, iv},
    key2,
  );
  log(final);

</script>


</body>
</html>
