<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="keywords" content="JavaScript, ES6, functional, simpatico, minimalist, web verite">
  <meta name="author" content="javajosh">

  <!-- Begin testable.js html boilerplate; testable.js is in the same directory -->
  <link id="favicon" rel="icon" type="image/svg+xml" href="data:image/svg+xml,
  <svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1 1'>
      <rect width='1' height='1' fill='white' />
  </svg>"/>
  <meta id="refresh" http-equiv="refresh" content="2">
  <script src="/testable.js" type="module"></script>
  <!-- End testable.js boilerplate  -->

  <title>crypto</title>
  <link rel="stylesheet" href="/style.css">
</head>
<body>
<h1>crypto</h1>
<p>javajosh <i>2023</i></p>
<div class="makeItStop"></div>

<h2>Encrypt/Decrypt</h2>
<p>
  Exercise cryptographic primitives.
  In this case use the crypto library to generate a key, encrypt a thing, then decrypt.
  Note that, at this point, we cannot save the generated keys for later use.
  This is enough to save ciphertext and later decrypt it.
  References:
</p>
<ol>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/generateKey">MDN's generateKey() docs</a></li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/exportKey">MDN's exportKey() docs</a></li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey">MDN's importKey() docs</a></li>
  <li><a href="https://w3c.github.io/webcrypto/#dfn-SubtleCrypto-method-generateKey">See the w3c web crypto spec</a></li>
  <li><a href="https://www.crypto101.io/">Crypto 101 is a good intro text to the field.</a></li>
</ol>


<script type="module">
  import {assertEquals, log, assert} from './core.js';
  import {generateSymmetricKey, encrypt, pack, decrypt, unpack, equalBuffers} from './crypto.js';

  // encrypt message
  const msg = 'Hey crypto cats!!';
  log('initializing', msg);
  const key = await generateSymmetricKey();
  log('generated key', key);
  const { cipherText, iv } = await encrypt(msg, key);
  log('encrypted message', {cipherText, iv});

  // await fetch('/secure-api', {
  //   method: 'POST',
  //   body: JSON.stringify({
  //     cipher: pack(cipher),
  //     iv: pack(iv),
  //   }),
  // })
  // const response = await fetch('/secure-api').then(res => res.json())

  const fakeResponse = {
    cipherText: pack(cipherText),
    iv: pack(iv),
  };

  const unpacked = {
    cipherText: unpack(fakeResponse.cipherText),
    iv: unpack(fakeResponse.iv),
  }
  log('fakeResponse', fakeResponse, 'unpacked', unpacked);
  assertEquals(unpacked.cipherText, cipherText);
  assert(equalBuffers(unpacked.iv, iv));

  // unpack and decrypt message
  const final = await decrypt(
    {cipherText, iv},
    key,
  );
  log('decrypted message', final);
  assertEquals(final, msg);
</script>

<h2>Export keys</h2>
<p>
  Export by picking a format and calling exportKey
  Format support depends on the type of underlying key.
  I believe that 'raw' is universally supported, however.
</p>

<script type="module">
  import {generateSymmetricKey, importSymmetricKey, pack, encrypt, decrypt} from './crypto.js';
  import {log, mapObject, getProp} from './core.js';

  //Make a key and encrypt something with it
  const key = await generateSymmetricKey();
  const { cipherText, iv } = await encrypt("hello!", key);

  // Export the key in raw; check what is supported with checkSupportedKeyExportFormats()
  let exportedKey = await window.crypto.subtle.exportKey('raw', key);
  const exportedKeyPacked = pack(exportedKey);
  log(exportedKey, exportedKeyPacked);

  const key2 = await importSymmetricKey(exportedKey, iv);

  // Now we can use the key again!
  const final = await decrypt(
    {cipherText, iv},
    key2,
  );
  log(final);

</script>

<h2>Asymmetric keys</h2>
<p>
  Now lets make asymmetric keys and use them to sign things, and also to wrap things.
</p>

<script type="module">
  import {encode} from './crypto.js';

  const msg = 'hello world';

  // Add an "A" and then figure out the arguments.
  // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/generateKey
  // https://developer.mozilla.org/en-US/docs/Web/API/EcKeyGenParams
  // name = ECDSA or ECDH
  // namedCurve = P-256, P-384, P-521
  const generateAsymmetricKey = () => {
    return window.crypto.subtle.generateKey({
      name: 'ECDSA',
      namedCurve: 'P-384',
    }, true, ['sign', 'verify'])
  }
  const keyPair = await generateAsymmetricKey();

  // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/sign
  // https://developer.mozilla.org/en-US/docs/Web/API/EcdsaParams
  const signature = await window.crypto.subtle.sign({
      name: 'ECDSA',
      hash: 'SHA-384'
    }, keyPair.privateKey,
    encode(msg)
  );
  console.log('keypair', keyPair, 'msg', msg, 'signature', signature);

  // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/verify
  // bool = verify(algorithm, key, signature, data)
  const verified = await window.crypto.subtle.verify({
      name: 'ECDSA',
      hash: 'SHA-384'
    }, keyPair.publicKey,
    signature,
    encode(msg),
  );
  console.log('verified', verified);

</script>

<h2>Exporting a derived symmetric key</h2>
<p>
  It turns out what we needed was the <a href="https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/deriveKey">deriveKey</a> method.
  However, I found a really good library, <a href="https://github.com/jo/webcryptobox">webcryptobox</a>, written in an eerily similar style as the rest of simpatico.
  It is small, build-less, written with modern ES6 and quite legible.
</p>

<script type="module">
  // The excellent https://github.com/jo/webcryptobox
  import * as wcb from './webcryptobox.js';
  import {assertEquals} from './core.js';

  const log = ('emit', 1) ? (await import('./core.js')).log : ()=>{};

  const alice = await wcb.generateKeyPair();
  const bob = await wcb.generateKeyPair();
  const text = 'Nobody else can offer me something, something heart felt like you did it.';
  const message = wcb.decodeText(text);
  const box = await wcb.encryptTo({ message, privateKey: alice.privateKey, publicKey: bob.publicKey });
  const decryptedBox = await wcb.decryptFrom({ box, privateKey: bob.privateKey, publicKey: alice.publicKey });
  const decryptedText = wcb.encodeText(decryptedBox);

  // Now lets see if we can export and import the keys and have it work the same way
  const alicePub = await wcb.exportPublicKeyPem(alice.publicKey);
  const alicePriv = await wcb.exportPrivateKeyPem(alice.privateKey);
  log('asymm', alicePub, alicePriv);
  const alicePubImported = await wcb.importPublicKeyPem(alicePub);
  const alicePrivImported = await wcb.importPrivateKeyPem(alicePriv);
  log('asymm', alicePubImported, alicePrivImported);
  const alice2 = {publicKey: alicePubImported, privateKey: alicePrivImported};
  const box2 = await wcb.encryptTo({ message, privateKey: alice2.privateKey, publicKey: bob.publicKey });
  log('asymm', alice2, box2);
  const decryptedBox2 = await wcb.decryptFrom({ box: box2, privateKey: bob.privateKey, publicKey: alice2.publicKey });
  const decryptedText2 = wcb.encodeText(decryptedBox2);

  assertEquals(decryptedText, decryptedText2);

</script>

<h1>Discussion</h1>
<p>
  Why crypto?
  Because you should encrypt all data at rest because of <a href="https://www.bleepingcomputer.com/news/security/google-finds-more-android-ios-zero-days-used-to-install-spyware/">exploits</a>.
</p>

</body>
</html>
