<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="keywords" content="Simpatico, rtree, es6">
  <meta name="author" content="Josh Rehman">

  <link id="favicon" rel="icon" type="image/png" href="./img/white.png"/>
  <meta id="refresh" http-equiv="refresh" content="2">
  <script type="module" src="testable.js"></script>

  <title>Combine.js</title>
  <link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
<div id="content">


<h1>Combine.js</h1>
<p>javajosh <i>(c) 2021</i></p>
<button onclick="window.stop()">Stop 2s Refresh</button>
<p>
  <code>combine(a, b)</code> combines two object arguments <code>b</code> with <code>a</code> and returns the object result.
  You can invoke functions, by targeting special parts of an object called <i>handlers</i>.
  Handlers are specialized functions that return objects that recursively integrate with the original target in a "message cascade".
  The intuition is of something like splashing in the water, with the water itself splashing up, and splashing again, until it the water is still again.
</p>
  <p>
    Collision and combination.
    An application is a list of values then connected together in useful ways by paths.
    The paths describe, in general, an stree who's various branches have been usefully combined into a cohesive interface.
    The degrees of freedom of this core can be said to be all of the arrays above.
    The computation that occurs is with the exploration of various paths through those values.
    Those paths are recorded independently as branches in an stree.
    It is a kind of generalization of the back button, such that you can move in and out of a nested data structure easily and smoothly, over time.
  </p>
</div>

<script type="module">
  import {combine, combineAll, combineAllArgs} from './combine.js';
  import {log, assertEquals, is, assertThrows} from './core.js';

  let result = null;

  // test() is a helper function to be used while testing the combine function
  // if expected is a function, then we just call the function on result. We expect it to assert stuff about result.
  // Otherwise, we do a deepEquals on expected and result (the usual case).
  const test = (target, msg, expected, print = false) => {
    result = combine(target, msg);
    if (print)
      log('combine.html/test()', 'target', target, 'msg', msg, 'expected', expected, 'result', result);
    if (is.fun(expected))
      expected(result)
    else
      assertEquals(expected, result);

    return result;
  };

  const UNIT = {};

  // scalars
  test(1, 1, 2) //numbers add
  test(9, null, 0) // zero out numbers with null
  test('a', 'b', 'b') // strings get replaced

  // ARRAYS
  test([], 1, [1]) // scalars are pushed
  test([], 'a', ['a'])
  test([1], 'a', [1, 'a'])
  // arrays are concatenated
  test([1, 2], [3, 4], [1, 2, 3, 4])
  // array can be emptied with null
  test([1, 2], null, [])

  // OBJECTS use all the scalar rules for their leaf keys.
  test({}, {}, {})
  test({}, {a: 1}, {a: 1})
  test({a: 1}, {a: 1}, {a: 2})
  // test({a:1},{b:2},{a:1, b:2}) //can't be properly auto-tested without a better equals for objects
  test({a: 99}, {a: null}, {a: 0})
  test({a: []}, {a: 1}, {a: [1]})

  // Undefined values have no effect
  test({a:1}, {a: undefined}, {a:1})

  // We can reach in deeply without touching the rest of the object.
  test({a: {b: 1}, c: 2}, {a: {b: 1}}, {a: {b: 2}, c: 2})

  // Functions are invoked.
  test(1, a => a + 1, 2)
  test(a => a + 1, 1, 2)
  // Nulling out a function
  test(a => a + 1, null, null)

  // Setting a function
  test(null, a => a + 1, fn => assertEquals(fn(1), 2))

  // A quick test of combine all and combine all args
  result = combineAll([{a: 1}, {a: 1}, {a: 1}, {a: 1}], {})
  assertEquals(result.a, 4)
  result = combineAllArgs({a: 1}, {a: 1}, {a: 1}, {a: 1}, {a: 1}, {a: 1}, {a: 1}, {a: 1})
  assertEquals(result.a, 8)

  // Handlers can call each other- forming a message cascade.
  // In this case, handler a also calls handler b. (but b doesn't call a)
  // For these simple handlers, the result is independent of both msg and ctx.
  const ha = {name: 'a', handle: () => [{a: 1}, b]}
  const hb = {name: 'b', handle: () => [{b: 1},  ]}
  const a  = {msg: 'a'}
  const b  = {msg: 'b'}
  const invalid = {msg: 'invalid'}
  result = combineAllArgs({}, ha, hb)

  // add 'a' 3 times, increment both a and b
  test(result, a, core => (core.a === 1 && core.b === 1))
  test(result, a, core => (core.a === 2 && core.b === 2))
  test(result, a, core => (core.a === 3 && core.b === 3))

  // add 'b' 3 times, incrementing only b
  test(result, b, core => (core.a === 3 && core.b === 4))
  test(result, b, core => (core.a === 3 && core.b === 5))
  test(result, b, core => (core.a === 3 && core.b === 6))

  // The empty object is a no-op message
  test(result, {}, core => (core.a === 3 && core.b === 6))

  // There is no matching handler for this message, so we should get an exception
  assertThrows(a => combine(result, invalid));

</script>

<div id="fib">
  <p>
    <span id="output">1</span>
    <button id="compute-next-fib-button">Compute Next Fibonacci Number</button>
  </p>
  <code><pre>
    const firstFibs = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89,144,233,377,610,987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811]
    let s = {a: 0, b: 1};
    s = combine(s, {a: s.b + '', b: s.a});
    display(s);
  </pre></code>

  <script type="module">
    import {svg, combine, log} from './simpatico.js';

    const DEBUG = true;
    const computeNextFibButton = svg.elt('compute-next-fib-button');
    const output = svg.elt('output');

    let s = {a: 0, b: 1};

    // The steady-state: compute the next fibonacci number interactively
    computeNextFibButton.addEventListener('click', _ => {
      s = combine(s, {a: s.b + '', b: s.a});
      display(s);
    });

    function display(s, elt=output){
      elt.innerText = s.b;
      if (DEBUG) log('s', s);
    }

  </script>
</div>

<div id="simple-combine">
  <script type="module">
    console.log(combine({a:[1,3,4]}, {a:[1]}))

    function combine(a, b) {
      // this convention implies b "acts on" a, in this case by 'zeroing a out' when b is null.
      // we can't zero out a boolean without introducing null, so we toggle it instead.
      if (typeof a === 'undefined' || a === null) return b; // 'something is better than nothing'
      if (typeof b === 'undefined') return a; // 'avoid special cases and let nothing compose as a noop'
      if (b === null) { // 'use null as a signal to set a type-dependent zero
        if (Array.isArray(a))       return [];
        if (typeof a === 'object')  return {};
        if (typeof a === 'number')  return 0;
        if (typeof a === 'string')  return '';
        if (typeof a === 'boolean') return !a;
      }

      // If both args are arrays, combine every element - concatenation is also a reasonable rule
      if (Array.isArray(a) && Array.isArray(b)) {
        return a.map((ai, i) => combine(ai, b[i]));
      }

      // If both args are plain objects, combine every shared key, and add the non-shared keys, too.
      if (typeof a === 'object' && typeof b === 'object' && !Array.isArray(a) && !Array.isArray(b)) {
        const result = {};
        for (const key of Object.keys(a)) {
          result[key] = a[key];
          if (key in b) {
            result[key] = combine(a[key], b[key]);
          }
        }
        for (const key of Object.keys(b)) {
          if (!(key in a)) {
            result[key] = b[key];
          }
        }
        return result;
      }

      if (typeof a === 'string' && typeof b === 'string') return b;
      if (typeof a === 'boolean' && typeof b === 'boolean') return b;
      if (typeof a === 'number' && typeof b === 'number') return a + b;

      throw `unable to combine ${a} and ${b}`
    }

  </script>
</div>
</body>
</html>
