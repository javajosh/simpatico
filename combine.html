<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="author" content="javajosh">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link id="favicon" rel="icon" type="image/png" href="./img/white.png"/>
  <title>Combine.js</title>

  <meta id="refresh" http-equiv="refresh" content="2">
  <script type="module" src="testable.js"></script>
</head>
<body>
<h1>Combine.js</h1>
<p>javajosh <i>(c) 2021</i></p>
<button onclick="window.stop()">Stop 2s Refresh</button>
<p>Combine(a, b) integrates b with a and returns the result. In the end, you can combine two objects such that
you can define any object by combining much simpler objects. We also support function invocation in two ways,
although the preferred way is invoking a handler. You do this by targeting handlers, which are specialized function
  invocations that recursively integrate the return object(s) in a process I call "message cascade". The visualization is
of something splashing in the water, with the water itself splashing, until it quickly comes to rest again.</p>

<p>Special care should be taken to avoid infinite recursion. At least in systems designed to be large collections of
closely related finite state machine (FSM) shared by humans in intricate relations to each other for the purpose of
modifying the numbers at banks in favor of the owner of the FSM. </p>
<pre>
  // scalars
  test(1, 1, 2) //numbers add
  test(9, null, 0) // zero out numbers with null
  test('a', 'b', 'b') // strings get replaced

  // ARRAYS
  test([], 1, [1]) // scalars are pushed
  test([], 'a', ['a'])
  test([1], 'a', [1, 'a'])
  // arrays are concatenated
  test([1, 2], [3, 4], [1, 2, 3, 4]);
  // array can be emptied with null
  test([1, 2], null, []);

  // OBJECTS use all the scalar rules for their leaf keys.
  test({}, {}, {});
  test({}, {a: 1}, {a: 1});
  test({a: 1}, {a: 1}, {a: 2});
  // test({a:1},{b:2},{a:1, b:2}); //can't be properly auto-tested without a better equals for objects
  test({a: 99}, {a: null}, {a: 0});
  test({a: []}, {a: 1}, {a: [1]});

  // We can reach in deeply without touching the rest of the object.
  test({a: {b: 1}, c: 2}, {a: {b: 1}}, {a: {b: 2}, c: 2})

  // Functions are invoked.
  test(1, a => a + 1, 2);
  test(a => a + 1, 1, 2);
  // Nulling out a function
  test(a => a + 1, null, null);

  // Setting a function
  test(null, a => a + 1, fn => assertEquals(fn(1), 2));
</pre>

<script type="module">
  import {combine, combineAll, combineAllArgs} from './combine.js';
  import {log, assert, assertEquals, is, assertThrows} from './core.js';

  let result = null;
  // test() is a helper function to be used while testing the combine function
  const test = (target, msg, expected, print = true) => {
    result = combine(target, msg);
    if (print) log('combine.html/test()', 'target', target, 'msg', msg, 'expected', expected, 'result', result);
    if (is.fun(expected)) expected(result)
    else assertEquals(expected, result);
    return result;
  };

  const UNIT = {};

  // scalars
  test(1, 1, 2) //numbers add
  test(9, null, 0) // zero out numbers with null
  test('a', 'b', 'b') // strings get replaced

  // ARRAYS
  test([], 1, [1]) // scalars are pushed
  test([], 'a', ['a'])
  test([1], 'a', [1, 'a'])
  // arrays are concatenated
  test([1, 2], [3, 4], [1, 2, 3, 4]);
  // array can be emptied with null
  test([1, 2], null, []);

  // OBJECTS use all the scalar rules for their leaf keys.
  test({}, {}, {});
  test({}, {a: 1}, {a: 1});
  test({a: 1}, {a: 1}, {a: 2});
  // test({a:1},{b:2},{a:1, b:2}); //can't be properly auto-tested without a better equals for objects
  test({a: 99}, {a: null}, {a: 0});
  test({a: []}, {a: 1}, {a: [1]});

  // We can reach in deeply without touching the rest of the object.
  test({a: {b: 1}, c: 2}, {a: {b: 1}}, {a: {b: 2}, c: 2})

  // Functions are invoked.
  test(1, a => a + 1, 2);
  test(a => a + 1, 1, 2);
  // Nulling out a function
  test(a => a + 1, null, null);

  // Setting a function
  test(null, a => a + 1, fn => assertEquals(fn(1), 2));

  // Handlers can call each other- forming a message cascade.
  // In this case, handler a also calls handler b. (but b doesn't call a)
  result = combine(UNIT, {
    name: 'a',
    handle: (ctx, msg) => [{a: 1}, {msg: 'b'}],
  });
  result = combine(result, {
    name: 'b',
    handle: (ctx, msg) => [{b: 1}],
  });
  result = combine(result, {msg: 'a'});
  assert(result.a === 1 && result.b === 1);
  result = combine(result, {msg: 'a'});
  assert(result.a === 2 && result.b === 2);
  result = combine(result, {msg: 'b'});
  assert(result.a === 2 && result.b === 3);

  // TODO test combine with dom elements.

  // TODO: explore what "combineAll()" looks like and how it works.
  // Method one - the straight-forward loop
  const a = (arr, residue = {}) => {
    for (let i = 0; i < arr.length; i++) {
      residue = combine(residue, arr[i]);
    }
    return residue;
  };
  result = a([{a: 1}, {a: 1}], {});
  assertEquals(result.a, 2);

  // Method two - the reduction
  const b = (arr, residue = {}) => arr.reduce(combine, residue);
  // TODO: figure out why this throws a rule error. It's almost like the default rule isn't being set.
  // are defaults ignored by Array.reduce somehow?
  assertThrows(() => {
    result = b([{a: 1}, {a: 1}, {a: 1}], {}); //this part throws
    assertEquals(result.a, 3);
  });

  result = combineAll([{a: 1}, {a: 1}, {a: 1}, {a: 1}], {});
  assertEquals(result.a, 4);

  result = combineAllArgs({a: 1}, {a: 1}, {a: 1}, {a: 1}, {a: 1}, {a: 1}, {a: 1}, {a: 1});
  assertEquals(result.a, 8);

</script>
</body>
</html>
