<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="keywords" content="Simpatico, rtree, es6">
  <meta name="author" content="Josh Rehman">

  <link id="favicon" rel="icon" type="image/png" href="./img/white.png"/>
  <meta id="refresh" http-equiv="refresh" content="2">
  <script type="module" src="testable.js"></script>

  <title>Combine.js</title>
  <link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
<div id="content">
  <h1>Combine.js</h1>
  <p>javajosh <i>(c) 2021</i></p>
  <button onclick="window.stop()">Stop 2s Refresh</button>
  <p>
    <code>combine(a, b)</code> combines two object arguments <code>b</code> with <code>a</code> and returns the object result.
    You can invoke functions, by targeting special parts of an object called <i>handlers</i>.
    Handlers are specialized functions that return objects that recursively integrate with the original target in a "message cascade".
    The intuition is of something like splashing in the water, with the water itself splashing up, and splashing again, until it the water is still again.
  </p>
  <p>
    Collision and combination.
    An application is a list of values then connected together in useful ways by paths.
    The paths describe, in general, an stree who's various branches have been usefully combined into a cohesive interface.
    The degrees of freedom of this core can be said to be all of the arrays above.
    The computation that occurs is with the exploration of various paths through those values.
    Those paths are recorded independently as branches in an stree.
    It is a kind of generalization of the back button, such that you can move in and out of a nested data structure easily and smoothly, over time.
  </p>
</div>

<script type="module">
  import {combine, combineAll, combineAllArgs} from './combine.js';
  import {log, assertEquals, is, assertThrows} from './core.js';

  let result = null;

  // test() is a helper function to be used while testing the combine function
  // if expected is a function, then we just call the function on result. We expect it to assert stuff about result.
  // Otherwise, we do a deepEquals on expected and result (the usual case).
  const test = (target, msg, expected, print = false) => {
    result = combine(target, msg);
    if (print)
      log('combine.html/test()', 'target', target, 'msg', msg, 'expected', expected, 'result', result);
    if (is.fun(expected))
      expected(result)
    else
      assertEquals(expected, result);

    return result;
  };

  const UNIT = {};

  // scalars
  test(1, 1, 2) //numbers add
  test(9, null, 0) // zero out numbers with null
  test('a', 'b', 'b') // strings get replaced

  // ARRAYS
  test([], 1, [1]) // scalars are pushed
  test([], 'a', ['a'])
  test([1], 'a', [1, 'a'])
  // arrays are concatenated
  test([1, 2], [3, 4], [1, 2, 3, 4])
  // array can be emptied with null
  test([1, 2], null, [])

  // OBJECTS use all the scalar rules for their leaf keys.
  test({}, {}, {})
  test({}, {a: 1}, {a: 1})
  test({a: 1}, {a: 1}, {a: 2})
  // test({a:1},{b:2},{a:1, b:2}) //can't be properly auto-tested without a better equals for objects
  test({a: 99}, {a: null}, {a: 0})
  test({a: []}, {a: 1}, {a: [1]})

  // Undefined values have no effect
  test({a:1}, {a: undefined}, {a:1})

  // We can reach in deeply without touching the rest of the object.
  test({a: {b: 1}, c: 2}, {a: {b: 1}}, {a: {b: 2}, c: 2})

  // Functions are invoked.
  test(1, a => a + 1, 2)
  test(a => a + 1, 1, 2)
  // Nulling out a function
  test(a => a + 1, null, null)

  // Setting a function
  test(null, a => a + 1, fn => assertEquals(fn(1), 2))

  // A quick test of combine all and combine all args
  result = combineAll([{a: 1}, {a: 1}, {a: 1}, {a: 1}], {})
  assertEquals(result.a, 4)
  result = combineAllArgs({a: 1}, {a: 1}, {a: 1}, {a: 1}, {a: 1}, {a: 1}, {a: 1}, {a: 1})
  assertEquals(result.a, 8)

  // Handlers can call each other- forming a message cascade.
  // In this case, handler a also calls handler b. (but b doesn't call a)
  // For these simple handlers, the result is independent of both msg and ctx.
  const ha = {name: 'a', handle: () => [{a: 1}, b]}
  const hb = {name: 'b', handle: () => [{b: 1},  ]}
  const a  = {msg: 'a'}
  const b  = {msg: 'b'}
  const invalid = {msg: 'invalid'}
  result = combineAllArgs({}, ha, hb)

  // add 'a' 3 times, increment both a and b
  test(result, a, core => (core.a === 1 && core.b === 1))
  test(result, a, core => (core.a === 2 && core.b === 2))
  test(result, a, core => (core.a === 3 && core.b === 3))

  // add 'b' 3 times, incrementing only b
  test(result, b, core => (core.a === 3 && core.b === 4))
  test(result, b, core => (core.a === 3 && core.b === 5))
  test(result, b, core => (core.a === 3 && core.b === 6))

  // The empty object is a no-op message
  test(result, {}, core => (core.a === 3 && core.b === 6))

  // There is no matching handler for this message, so we should get an exception
  assertThrows(a => combine(result, invalid));

</script>

<div id="fib">
  <p>
    <span id="output">1</span>
    <button id="compute-next-fib-button">Compute Next Fibonacci Number</button>
  </p>
  <code><pre>
    const firstFibs = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89,144,233,377,610,987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811]
    let s = {a: 0, b: 1};
    s = combine(s, {a: s.b + '', b: s.a});
    display(s);
  </pre></code>

  <script type="module">
    import {svg, combine, log} from './simpatico.js';

    const DEBUG = true;
    const computeNextFibButton = svg.elt('compute-next-fib-button');
    const output = svg.elt('output');

    let s = {a: 0, b: 1};

    // The steady-state: compute the next fibonacci number interactively
    computeNextFibButton.addEventListener('click', _ => {
      s = combine(s, {a: s.b + '', b: s.a});
      display(s);
    });

    function display(s, elt=output){
      elt.innerText = s.b;
      if (DEBUG) log('s', s);
    }

  </script>
</div>

<div id="simple-combine">
  <p>
    I like this code. I will need to convert this page to markdown and then write about it more.
  </p>
  <script type="module">
    import {assertEquals, mapObject} from './core.js';

    const DEBUG = false;
    const isNum = d => Number.isInteger(d);
    const isStr = d => typeof d === 'string';
    const isArray = d => Array.isArray(d);
    const isObj = a => typeof a === 'object' && !isArray(a);
    const isScalar = a => !isArray(a) && !isObj(a);
    const peek = (arr, def=null) => {
      if (!isArray(arr) || arr.length === 0) return def;
      if (arr.length === 1) return arr[0];
      return arr[arr.length - 1];
    }
    const isCore = a =>    typeof a === 'object' && a.hasOwnProperty('handlers') && typeof a['handlers'] === 'object';
    const isHandler = a => typeof a === 'object' && a.hasOwnProperty('handle')   && typeof a['handle'  ] === 'function';
    const isMsg = a =>     typeof a === 'object' && a.hasOwnProperty('handler')  && typeof a['handler' ] === 'string';
    const isInstance = a =>isCore(a) && a.hasOwnProperty('nodeId') && isNum(a);
    const isType = a =>    isCore(a) && a.hasOwnProperty('type') && typeof a['type'] === 'string';

    const assertHandler = { handle: (core, msg) => {
        Object.entries(msg).forEach(([key, msgValue]) => {
          if (key === 'handler' || key === 'parent') return; // skip the handler name itself
          if (core.hasOwnProperty(key)) assertEquals(msgValue, core[key]);
          else throw 'core is missing asserted property ' + key;
        });
        return [{}]
      }};

    // Test basic assertions about combine
    {
      assertEquals({a: [2, 3, 4]}, combine({a: [1, 3, 4]}, {a: [1]}));
      assertEquals({a: [2, 3, {b: 2}], c: false}, combine({a: [1, 3, {b: 1}]}, {a: [1, 0, {b: 1}], c: false}))

      // Noops
      assertEquals({a: [1, 3, {b: 1}]}, combine({a: [1, 3, {b: 1}]}, undefined));
      assertEquals({a: [1, 3, {b: 1}]}, combine({a: [1, 3, {b: 1}]}, {}));

      assertEquals({}, combine({a: [1, 3, {b: 1}]}, null))
      assertEquals({a: []}, combine({a: [1, 3, {b: 1}]}, {a: null}))

      // Boolean has an odd behavior with null - let's test it.
      assertEquals(true, combine(false, null));
      assertEquals(false, combine(true, null));
      assertEquals(true, combine(false, true));
      assertEquals(false, combine(true, false));

      // Strings replace
      assertEquals('', combine('anything', null));
      assertEquals('b', combine('a', 'b'));
      // Numbers add
      assertEquals(3, combine(1, 2));
    }

    // Create a (very contrived) core from handlers and run it through a list of operations
    {
      const log = {handle: (...args)        => { if (DEBUG) console.log(args); return {}; } };
      const inc = {handle: ()            => [{a: 1}, {b: 2}]};
      const sum = {handle: (_  , {a, b}) => [{a: a + b}]};
      const mul = {handle: ({a}, {a: b}) => [{a: null}, {a: a * b}]}; // clear out the previous value with the null set
      // We can test handlers on their own, as simple pure functions:
      assertEquals({},                log.handle(1, 2));
      assertEquals([{a: 1}, {b: 2}],    inc.handle());
      assertEquals([{a: 5}],            sum.handle({}, {a: 2, b: 3}));
      assertEquals([{a: null}, {a: 6}], mul.handle({a: 2}, {a: 3}));

      // We use these handlers to form a "core" and treat input as a monotonic sequence of object additions.
      let core = {handlers: {log, inc, sum, mul, assert: assertHandler}};

      // 1: a simple case: all handlers are available all the time and can be called in any order.
      const ops = [
        {handler: 'log'},
        {handler: 'inc'},
        {handler: 'assert', a: 1, b: 2},
        {handler: 'inc'},
        {handler: 'assert', a: 2, b: 4},
        {a: null},
        {handler: 'assert', a: 0},
        {handler: 'sum', a: 1, b: 2},
        {handler: 'assert', a: 3},
        {a: null},
        {a: 2},
        {a: 2},
        {handler: 'assert', a: 4},
        {handler: 'mul', a: 10},
        {handler: 'assert', a: 40},
        {handler: 'log'},
      ];
      ops.every(op => core = combine(core, op));

      // 2: Now lets experiment with adding integers to the operations list, forming a trie
      const o = {};
      const a1 = {a: 1};
      const a2 = {a: 2};
      const a3 = {a: 3};
      const a4 = {a: 4};
      const a5 = {a: 5};
      const a6 = {a: 6};

      const ops2 = [
        o, a1, a2,
        0, a3, a4,
        2, a5,
        -1, a6
      ];
      const {nodes, rows, branches} = buildTree(ops2);
      assertEquals([o, a1, a2, a3, a4, a5, a6], nodes);
      assertEquals([
        [o, a1, a2],
        [0, a3, a4, a6],
        [2, a5]
        ], rows);
      assertEquals([
        [o, a1, a2],
        [o, a3, a4, a6],
        [o, a1, a2, a5]
        ], branches());

      // 3: Same as ops but with more interspersed integers
      const ops3 = [
        {handler: 'log'},
        {handler: 'inc'},
        {handler: 'assert', a: 1, b: 2},
        {handler: 'inc'},
        {handler: 'assert', a: 2, b: 4},
        2,
        {a: null},
        {handler: 'assert', a: 0},
        {handler: 'sum', a: 1, b: 2},
        {handler: 'assert', a: 3},
        {a: null},
        {a: 3},
        {a: 2},
        {handler: 'assert', a: 5},
        {handler: 'mul', a: 10},
        {handler: 'assert', a: 50},
        {handler: 'log'},
      ];
      const {branches: branches3, allBranchesReachable, residues, summary} = buildTree(ops3);
      allBranchesReachable({handlers: {log, inc, sum, mul, assert: assertHandler}});
      if (DEBUG) console.log('branches3()', branches3(), 'residues', residues, 'summary', summary);
    }

    // (Re) building out an example of classic OOP types and instantiation with Simpatico
    {
      const h1 = { handle: (a, b) => [{b}],            example: {handler: 'h1', b:1} };
      const h2 = { handle: (a, b) => [{a: null}] ,     example: {handler: 'h2'} };
      const h3 = { handle: (a, b) => [{a: 1}, {b: 2}], example: {handler: 'h3'} };
      const h4 = { handle: (a, b) => [{b: null}],      example: {handler: 'h4'} };

      // helper functions to build the ops
      const h = a => [0,h1,h2,h3,h4][a].example;
      const a = a => ({a});
      const b = b => ({b});
      const as = a => ({handler: 'assert', ...a});
      assertEquals({handler: 'h1', b:1}, h(1));
      assertEquals({handler: 'h4'}, h(4));
      assertEquals({a: 2}, a(2));
      assertEquals({handler: 'assert', a: 7}, as({a:7}));

      // In this case we're building up a simple type tree and instantiating some of the types (and asserting things)
      const ops = [
        {handlers: {assert: assertHandler}},
        0, {type: 'foo'}, {handlers: {h1, h2}},    // the last elt in this row is node index 2
        0, {type: 'bar'}, {handlers: {h3}}, {handlers: {h4}}, // last elt in row is 5; note the split handlers, which is equiv.
        0, {type: 'baz'}, {handlers: {h3, h4}},   // last elt in row is 7
        2, a(2), as({a: 2}), a(2), as({type: 'foo', a:4}),     // instance of foo, pointing to node index 2
        5, a(5), as({a: 5}),                      // instance of bar, pointing to node index 5
        7, a(8), a(1), b(10), as({a: 9, b: 10}),  // instance of baz, pointing to node index 7
      ];
      const {branches, allBranchesReachable, residues, summary, nodes, neu} = buildTree(ops);
      allBranchesReachable();
      console.log('branches()', branches(), 'residues', residues, 'nodes', nodes, 'summary', summary);

      // todo: demonstrate type versioning; explore a way to avoid calculating node offsets for instance rows.
      // a reasonable desire would be to target a type by row and create a new instance based on the current type length
      // this messes up the general authoring, but if you limit yourself to only instantiating after the type rows, it can be done!
      // We add special logic into the tree "add" method that does something special if a type row.
      // This in turn requires a relatively fast residue computation.

      console.log(neu(-1), 'branches()', branches(), 'residues', residues, 'nodes', nodes);
      console.log(neu(-2), 'branches()', branches(), 'residues', residues, 'nodes', nodes);
      console.log(neu('foo'), 'branches()', branches(), 'residues', residues, 'nodes', nodes);

      // For some reason now is the time to play with function de/serialization.
      {
        const serializeHandler = a => {
          a.handle = a.handle.toString();
          return a;
        }
        const deserializeHandler = a => {
          // We can and should do some more validation and checking, perhaps limit length, for security purposes.
          a.handle = eval(a.handle);
          return a;
        }
        const h6 = {handle: '(a, b) => 42'};
        const h7 = {handle: (a, b) => 42};
        assertEquals(h6.handle, h7.handle.toString());
        assertEquals(h6, serializeHandler(h7))
        assertEquals(h7.handle.toString(), deserializeHandler(h6).handle.toString());

        const serializeOps = ops => {
          // This is awful, I should use map() and not mutate with delete,
          ops.every(op => {
            if (!isObj(op)) return;
            delete op[parent];
            if (isCore(op))
              op.handlers = mapObject(op.handlers, ([k, v]) => [k, serializeHandler(v)])
            return true;
          });
          return ops;
        };

        const deserializeOps = ops => {
          ops.every(op => {
            if (isCore(op))
              // This is awful, I should use map() and not mutate with reassignment,
              op.handlers = mapObject(op.handlers, ([k, v]) => [k, deserializeHandler(v)])
          });
          return ops;
        };
        assertEquals([], serializeOps([]));
        assertEquals([a(1)], serializeOps([a(1)]));
        // assertEquals([{handlers: {h6: h6.toString()}}], serializeOps([{handlers: {h6: h7.toString()}}]));
        // assertEquals([{handlers: {h7}}], deserializeOps([{handlers: {h6}}]));
      }
    }

    // A much simpler combine not for production use - just playing with some ideas.
    function combine(a, b) {
      // this convention implies b "acts on" a, in this case by 'zeroing a out' when b is null.
      // we can't zero out a boolean without introducing null, so we toggle it instead.
      // combine is not associative, but it does have an identity and a zero.
      if (typeof a === 'undefined' || a === null) return b; // 'something is better than nothing'
      if (typeof b === 'undefined') return a; // 'avoid special cases and let nothing compose as a noop'
      if (b === null) { // 'use null as a signal to set a type-dependent zero
        if (Array.isArray(a))       return [];
        if (typeof a === 'object')  return {};
        if (typeof a === 'number')  return  0;
        if (typeof a === 'string')  return '';
        if (typeof a === 'boolean') return !a;
        if (typeof a === 'function') return () => {};
      }

      // If both args are arrays, combine every element - concatenation is also a reasonable rule
      if (Array.isArray(a) && Array.isArray(b)) {
        return a.map((ai, i) => combine(ai, b[i]));
      }

      // if the target is an array, push the argument onto the array
      if (Array.isArray(a) && !Array.isArray(b)) {
        a.push(b);
        return a;
      }

      // If both args are plain objects, combine every shared key, and add the non-shared keys, too.
      if (isObj(a) && isObj(b)) {
        if (isCore(a) && isMsg(b)){
          if (!isHandler(a.handlers[b.handler])) throw `Unable to find valid handler ${b.handler} in core ${a}`;
          let result = a.handlers[b.handler].handle(a, b);
          if (!Array.isArray(result)) result = [result];
          result.every(obj => a = combine(a, obj));
          return a;
        }
        const result = {};
        for (const key of Object.keys(a)) {
          result[key] = a[key];
          if (key in b) {
            result[key] = combine(a[key], b[key]);
          }
        }
        for (const key of Object.keys(b)) {
          if (!(key in a)) {
            result[key] = b[key];
          }
        }
        return result;
      }

      if (typeof a === 'string'   && typeof b === 'string'  ) return b;
      if (typeof a === 'boolean'  && typeof b === 'boolean' ) return b;
      if (typeof a === 'function' && typeof b === 'function') return b;
      if (typeof a === 'number'   && typeof b === 'number'  ) return a + b;

      throw `unable to combine ${a} and ${b} types ${typeof a} ${typeof b}`
    }

    // Take an array with sprinkled integers and turn it into a tree of related elements
    function buildTree(arr = [{}]) {
      const rows = [[]];
      const nodes = [];
      const residues = [];
      let summary = {};
      let currRow = rows[0];

      // Support cheap(er) creation of branch state from row state
      // Given a node index, give me the row that contains the node up to the node.
      // We can do this statelessly with indexOf, but this is much faster.
      let currRowIndex = 0;
      let nodeToRowMap = [];
      const getPartialRow = nodei => {
        const [rowi, coli] = nodeToRowMap[nodei];
        const row = rows[rowi];
        return row.slice(0, coli + 1); // tricky: slice does not include the last elt!
      }

      arr.every(add);

      function add(d) {
        if (isNum(d) && d >= 0 ){
          // Positive numbers mean the target is a node
          if (d >= nodes.length) throw 'invalid parent node ' + d;
          currRow = [d];
          currRowIndex = rows.length;
          rows.push(currRow);
        } else if(isNum(d) && d < 0) {
          // Negative numbers means the target is a row.
          if (-d >= rows.length) throw 'invalid row ' + d;
          currRow = rows[-d];
          currRowIndex = -d;
        } else {
          // Special handling for neu messages - delegate to neu() and
          if (isObj(d) && d.hasOwnProperty('neu')){
            neu(d);
            return true;
          }
          // Support for efficient branches()
          nodeToRowMap.push([currRowIndex, currRow.length]);

          // The primary purpose, adding things to the current row and nodes.
          currRow.push(d);
          nodes.push(d);

          // Update caches for residue and summary.
          try {
            residues[currRowIndex] = combine(residues[currRowIndex], d);
            summary = residues.reduce(combine, {});
          } catch (e) {

          }
        }
        return true;
      }

      // A more handy way to make instances than the raw add(node) interface.
      // Given either a type name or type row, create a new instance row.
      // Cores that only instantiates using this method have some nice properties.
      // Note: 'neu' is German for 'new' which is a reserved word in JavaScript.
      function neu(d){
        let type, rowNum, residue, parentNodeId, newNodeId;
        if (isNum(d)){
          rowNum = -d;
          residue = residues[rowNum];
          if (!isType(residue) || isInstance(residue)) throw `row ${d} cannot be instantiated with neu()`;
        } else if (isStr(d)){
          type = d;
          let found = null;
          residues.every((r, i) => {
            if (isType(r) && !isInstance(r) && r.type === type) { found = i; return false; }
            return true;
          });
          if (!isNum(found)) throw `type ${d} not found`;
          rowNum = found;
        }
        residue = residues[rowNum];
        if (!isType(residue)) throw `row ${rowNum} is not a type and cannot be instantiated with neu()`;
        type = residue.type;
        parentNodeId = nodes.indexOf(peek(rows[rowNum]));
        newNodeId = nodes.length;
        add(parentNodeId);
        add({nodeId: newNodeId, type, parentNodeId});
        return rowNum;
      }

      const branchTips = () => rows.map(row => {
        let node = peek(row);
        return nodes.indexOf(node);
      });

      // Prepend partial rows until root.
      const branches = () => rows.map(row => {
        let result = [...row], partial = [...row], nodei;
        while (isNum(result[0])) {
          nodei = result.shift();
          partial = getPartialRow(nodei);
          result = [...partial, ...result];
        }
        return result;
      });

      // Return true if the given core can reach all points on all branches of this tree.
      const allBranchesReachable = core => branches().every((branch, branchi) => {
        let state = core; // reset the core before every branch
        return branch.every((op, opi) => {
          try {
            state = combine(state, op);
            return true;
          } catch (e) {
            console.error(`cannot combine op ${JSON.stringify(op)} op i ${opi} at branch i ${branchi} and core ${JSON.stringify(core)}`);
            throw e;
          }
        });
      });

      // These are the stateless methods to compute residue and summary. Very compute intensive.
      // Map each branch to a residue by reducing the branch under combine
      // const residues = (reduction=combine, start={}) => branches().map(branch => branch.reduce(reduction, start));
      // Combine all the residues into a summary, by default using combine for both reductions
      // const summary = (r1=combine, r2=combine, s1={}, s2={}) => residues(r1, s1).reduce(r2, s2);

      return {
        add,
        neu,
        allBranchesReachable,
        rows,
        nodes,
        residues,
        summary,
        branches,
        branchTips,
      };
    }

  </script>
</div>
</body>
</html>
