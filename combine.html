<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="keywords" content="Simpatico, rtree, es6">
  <meta name="author" content="Josh Rehman">

  <link id="favicon" rel="icon" type="image/png" href="./img/white.png"/>
  <meta id="refresh" http-equiv="refresh" content="2">
  <script type="module" src="testable.js"></script>

  <title>Combine.js</title>
  <link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
<h1>Combine.js</h1>
<p>javajosh <i>(c) 2021</i></p>
<button onclick="window.stop()">Stop 2s Refresh</button>
<p>
  <code>combine(a, b)</code> combines two object arguments <code>b</code> with <code>a</code> and returns the object result.
  You can invoke functions, by targeting special parts of an object called <i>handlers</i>.
  Handlers are specialized functions that return objects that recursively integrate with the original target in a "message cascade".
  The intuition is of something like splashing in the water, with the water itself splashing up, and splashing again, until it the water is still again.
</p>

<pre>
  // scalars
  test(1, 1, 2) //numbers add
  test(9, null, 0) // zero out numbers with null
  test('a', 'b', 'b') // strings get replaced

  // ARRAYS
  test([], 1, [1]) // scalars are pushed
  test([], 'a', ['a'])
  test([1], 'a', [1, 'a'])
  // arrays are concatenated
  test([1, 2], [3, 4], [1, 2, 3, 4]);
  // array can be emptied with null
  test([1, 2], null, []);

  // OBJECTS use all the scalar rules for their leaf keys.
  test({}, {}, {});
  test({}, {a: 1}, {a: 1});
  test({a: 1}, {a: 1}, {a: 2});
  // test({a:1},{b:2},{a:1, b:2}); //can't be properly auto-tested without a better equals for objects
  test({a: 99}, {a: null}, {a: 0});
  test({a: []}, {a: 1}, {a: [1]});

  // We can reach in deeply without touching the rest of the object.
  test({a: {b: 1}, c: 2}, {a: {b: 1}}, {a: {b: 2}, c: 2})

  // Functions are invoked.
  test(1, a => a + 1, 2);
  test(a => a + 1, 1, 2);
  // Nulling out a function
  test(a => a + 1, null, null);

  // Setting a function
  test(null, a => a + 1, fn => assertEquals(fn(1), 2));
</pre>

<script type="module">
  import {combine, combineAll, combineAllArgs} from './combine.js';
  import {log, assert, assertEquals, is, assertThrows} from './core.js';

  let result = null;
  // test() is a helper function to be used while testing the combine function
  const test = (target, msg, expected, print = true) => {
    result = combine(target, msg);
    if (print) log('combine.html/test()', 'target', target, 'msg', msg, 'expected', expected, 'result', result);
    if (is.fun(expected)) expected(result)
    else assertEquals(expected, result);
    return result;
  };

  const UNIT = {};

  // scalars
  test(1, 1, 2) //numbers add
  test(9, null, 0) // zero out numbers with null
  test('a', 'b', 'b') // strings get replaced

  // ARRAYS
  test([], 1, [1]) // scalars are pushed
  test([], 'a', ['a'])
  test([1], 'a', [1, 'a'])
  // arrays are concatenated
  test([1, 2], [3, 4], [1, 2, 3, 4]);
  // array can be emptied with null
  test([1, 2], null, []);

  // OBJECTS use all the scalar rules for their leaf keys.
  test({}, {}, {});
  test({}, {a: 1}, {a: 1});
  test({a: 1}, {a: 1}, {a: 2});
  // test({a:1},{b:2},{a:1, b:2}); //can't be properly auto-tested without a better equals for objects
  test({a: 99}, {a: null}, {a: 0});
  test({a: []}, {a: 1}, {a: [1]});

  // We can reach in deeply without touching the rest of the object.
  test({a: {b: 1}, c: 2}, {a: {b: 1}}, {a: {b: 2}, c: 2})

  // Functions are invoked.
  test(1, a => a + 1, 2);
  test(a => a + 1, 1, 2);
  // Nulling out a function
  test(a => a + 1, null, null);

  // Setting a function
  test(null, a => a + 1, fn => assertEquals(fn(1), 2));

  // Handlers can call each other- forming a message cascade.
  // In this case, handler a also calls handler b. (but b doesn't call a)
  result = combine(UNIT, {
    name: 'a',
    handle: (ctx, msg) => [{a: 1}, {msg: 'b'}],
  });
  result = combine(result, {
    name: 'b',
    handle: (ctx, msg) => [{b: 1}],
  });
  result = combine(result, {msg: 'a'});
  assert(result.a === 1 && result.b === 1);
  result = combine(result, {msg: 'a'});
  assert(result.a === 2 && result.b === 2);
  result = combine(result, {msg: 'b'});
  assert(result.a === 2 && result.b === 3);

  // TODO test combine with dom elements.

  // TODO: explore what "combineAll()" looks like and how it works.
  // Method one - the straight-forward loop
  const a = (arr, residue = {}) => {
    for (let i = 0; i < arr.length; i++) {
      residue = combine(residue, arr[i]);
    }
    return residue;
  };
  result = a([{a: 1}, {a: 1}], {});
  assertEquals(result.a, 2);

  // Method two - the reduction
  const b = (arr, residue = {}) => arr.reduce(combine, residue);
  // TODO: figure out why this throws a rule error. It's almost like the default rule isn't being set.
  // are defaults ignored by Array.reduce somehow?
  assertThrows(() => {
    result = b([{a: 1}, {a: 1}, {a: 1}], {}); //this part throws
    assertEquals(result.a, 3);
  });

  result = combineAll([{a: 1}, {a: 1}, {a: 1}, {a: 1}], {});
  assertEquals(result.a, 4);

  result = combineAllArgs({a: 1}, {a: 1}, {a: 1}, {a: 1}, {a: 1}, {a: 1}, {a: 1}, {a: 1});
  assertEquals(result.a, 8);

</script>
</body>
</html>
