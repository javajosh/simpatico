<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="keywords" content="Simpatico, rtree, es6">
  <meta name="author" content="Josh Rehman">

  <link id="favicon" rel="icon" type="image/png" href="./img/white.png"/>
  <meta id="refresh" http-equiv="refresh" content="2">
  <script type="module" src="testable.js"></script>

  <title>Combine.js</title>
  <link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
<div id="content">
  <h1>Combine.js</h1>
  <p>javajosh <i>(c) 2021</i></p>
  <button onclick="window.stop()">Stop 2s Refresh</button>
  <p>
    <code>combine(a, b)</code> combines two object arguments <code>b</code> with <code>a</code> and returns the object result.
    You can invoke functions, by targeting special parts of an object called <i>handlers</i>.
    Handlers are specialized functions that return objects that recursively integrate with the original target in a "message cascade".
    The intuition is of something like splashing in the water, with the water itself splashing up, and splashing again, until it the water is still again.
  </p>
  <p>
    Collision and combination.
    An application is a list of values then connected together in useful ways by paths.
    The paths describe, in general, an stree who's various branches have been usefully combined into a cohesive interface.
    The degrees of freedom of this core can be said to be all of the arrays above.
    The computation that occurs is with the exploration of various paths through those values.
    Those paths are recorded independently as branches in an stree.
    It is a kind of generalization of the back button, such that you can move in and out of a nested data structure easily and smoothly, over time.
  </p>
</div>

<script type="module">
  import {combine, combineAll, combineAllArgs} from './combine.js';
  import {log, assertEquals, is, assertThrows} from './core.js';

  let result = null;

  // test() is a helper function to be used while testing the combine function
  // if expected is a function, then we just call the function on result. We expect it to assert stuff about result.
  // Otherwise, we do a deepEquals on expected and result (the usual case).
  const test = (target, msg, expected, print = false) => {
    result = combine(target, msg);
    if (print)
      log('combine.html/test()', 'target', target, 'msg', msg, 'expected', expected, 'result', result);
    if (is.fun(expected))
      expected(result)
    else
      assertEquals(expected, result);

    return result;
  };

  const UNIT = {};

  // scalars
  test(1, 1, 2) //numbers add
  test(9, null, 0) // zero out numbers with null
  test('a', 'b', 'b') // strings get replaced

  // ARRAYS
  test([], 1, [1]) // scalars are pushed
  test([], 'a', ['a'])
  test([1], 'a', [1, 'a'])
  // arrays are concatenated
  test([1, 2], [3, 4], [1, 2, 3, 4])
  // array can be emptied with null
  test([1, 2], null, [])

  // OBJECTS use all the scalar rules for their leaf keys.
  test({}, {}, {})
  test({}, {a: 1}, {a: 1})
  test({a: 1}, {a: 1}, {a: 2})
  // test({a:1},{b:2},{a:1, b:2}) //can't be properly auto-tested without a better equals for objects
  test({a: 99}, {a: null}, {a: 0})
  test({a: []}, {a: 1}, {a: [1]})

  // Undefined values have no effect
  test({a:1}, {a: undefined}, {a:1})

  // We can reach in deeply without touching the rest of the object.
  test({a: {b: 1}, c: 2}, {a: {b: 1}}, {a: {b: 2}, c: 2})

  // Functions are invoked.
  test(1, a => a + 1, 2)
  test(a => a + 1, 1, 2)
  // Nulling out a function
  test(a => a + 1, null, null)

  // Setting a function
  test(null, a => a + 1, fn => assertEquals(fn(1), 2))

  // A quick test of combine all and combine all args
  result = combineAll([{a: 1}, {a: 1}, {a: 1}, {a: 1}], {})
  assertEquals(result.a, 4)
  result = combineAllArgs({a: 1}, {a: 1}, {a: 1}, {a: 1}, {a: 1}, {a: 1}, {a: 1}, {a: 1})
  assertEquals(result.a, 8)

  // Handlers can call each other- forming a message cascade.
  // In this case, handler a also calls handler b. (but b doesn't call a)
  // For these simple handlers, the result is independent of both msg and ctx.
  const ha = {name: 'a', handle: () => [{a: 1}, b]}
  const hb = {name: 'b', handle: () => [{b: 1},  ]}
  const a  = {msg: 'a'}
  const b  = {msg: 'b'}
  const invalid = {msg: 'invalid'}
  result = combineAllArgs({}, ha, hb)

  // add 'a' 3 times, increment both a and b
  test(result, a, core => (core.a === 1 && core.b === 1))
  test(result, a, core => (core.a === 2 && core.b === 2))
  test(result, a, core => (core.a === 3 && core.b === 3))

  // add 'b' 3 times, incrementing only b
  test(result, b, core => (core.a === 3 && core.b === 4))
  test(result, b, core => (core.a === 3 && core.b === 5))
  test(result, b, core => (core.a === 3 && core.b === 6))

  // The empty object is a no-op message
  test(result, {}, core => (core.a === 3 && core.b === 6))

  // There is no matching handler for this message, so we should get an exception
  assertThrows(a => combine(result, invalid));

</script>

<div id="fib">
  <p>
    <span id="output">1</span>
    <button id="compute-next-fib-button">Compute Next Fibonacci Number</button>
  </p>
  <code><pre>
    const firstFibs = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89,144,233,377,610,987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811]
    let s = {a: 0, b: 1};
    s = combine(s, {a: s.b + '', b: s.a});
    display(s);
  </pre></code>

  <script type="module">
    import {svg, combine, log} from './simpatico.js';

    const DEBUG = true;
    const computeNextFibButton = svg.elt('compute-next-fib-button');
    const output = svg.elt('output');

    let s = {a: 0, b: 1};

    // The steady-state: compute the next fibonacci number interactively
    computeNextFibButton.addEventListener('click', _ => {
      s = combine(s, {a: s.b + '', b: s.a});
      display(s);
    });

    function display(s, elt=output){
      elt.innerText = s.b;
      if (DEBUG) log('s', s);
    }

  </script>
</div>

<div id="simple-combine">
  <p>
    I like this code. I will need to convert this page to markdown and then write about it more.
  </p>
  <script type="module">
    import {assertEquals} from './core.js';

    const DEBUG = false;
    const isNum = d => typeof d === 'number';
    const peek = (arr, def=null) => arr.length ? arr[arr.length - 1] : def;
    const isCore = a =>    typeof a === 'object' && a.hasOwnProperty('handlers') && typeof a['handlers'] === 'object';
    const isHandler = a => typeof a === 'object' && a.hasOwnProperty('handle')   && typeof a['handle'  ] === 'function';
    const isMsg = a =>     typeof a === 'object' && a.hasOwnProperty('handler')  && typeof a['handler' ] === 'string';
    const isObj = a =>     typeof a === 'object' && !Array.isArray(a);

    // Test basic assertions about combine
    {
      assertEquals({a: [2, 3, 4]}, combine({a: [1, 3, 4]}, {a: [1]}));
      assertEquals({a: [2, 3, {b: 2}], c: false}, combine({a: [1, 3, {b: 1}]}, {a: [1, 0, {b: 1}], c: false}))

      // Noops
      assertEquals({a: [1, 3, {b: 1}]}, combine({a: [1, 3, {b: 1}]}, undefined));
      assertEquals({a: [1, 3, {b: 1}]}, combine({a: [1, 3, {b: 1}]}, {}));

      assertEquals({}, combine({a: [1, 3, {b: 1}]}, null))
      assertEquals({a: []}, combine({a: [1, 3, {b: 1}]}, {a: null}))

      // Boolean has an odd behavior with null - let's test it.
      assertEquals(true, combine(false, null));
      assertEquals(false, combine(true, null));
      assertEquals(true, combine(false, true));
      assertEquals(false, combine(true, false));

      // Strings replace
      assertEquals('', combine('anything', null));
      assertEquals('b', combine('a', 'b'));
      // Numbers add
      assertEquals(3, combine(1, 2));
    }

    // Create a (very contrived) core from handlers and run it through a list of operations
    {
      const log = { handle: (a, b) => {if (DEBUG) console.log(a, b)}};
      const inc = {handle: () => [{a: 1}, {b: 2}]};
      const sum = {handle: (_, {a, b}) => [{a: a + b}]};
      const mul = {handle: ({a}, {a: b}) => [{a: null}, {a: a * b}]}; // clear out the previous value with the null set
      const assert = {
        handle: (core, msg) => {
          Object.entries(msg).forEach(([key, msgValue]) => {
            if (key === 'handler' || key === 'parent') return; // skip the handler name itself
            if (core.hasOwnProperty(key)) assertEquals(msgValue, core[key]);
            else throw 'core is missing asserted property ' + key;
          });
        }
      };
      // We can test handlers on their own, as simple pure functions:
      assertEquals(undefined, log.handle(1, 2));
      assertEquals([{a: 1}, {b: 2}], inc.handle());
      assertEquals([{a: 5}], sum.handle({}, {a: 2, b: 3}));
      assertEquals([{a: null}, {a: 6}], mul.handle({a: 2}, {a: 3}));

      // We use these handlers to form a "core" and treat input as a monotonic sequence of object additions.
      let core = {handlers: {log, inc, sum, mul, assert}};

      // 1: a simple case: all handlers are available all the time and can be called in any order.
      const ops = [
        {handler: 'log'},
        {handler: 'inc'},
        {handler: 'assert', a: 1, b: 2},
        {handler: 'inc'},
        {handler: 'assert', a: 2, b: 4},
        {a: null},
        {handler: 'assert', a: 0},
        {handler: 'sum', a: 1, b: 2},
        {handler: 'assert', a: 3},
        {a: null},
        {a: 2},
        {a: 2},
        {handler: 'assert', a: 4},
        {handler: 'mul', a: 10},
        {handler: 'assert', a: 40},
        {handler: 'log'},
      ];
      ops.every(op => core = combine(core, op));

      // 2: Now lets experiment with adding integers to the operations list, forming a trie
      const o = {};
      const a1 = {a: 1};
      const a2 = {a: 2};
      const a3 = {a: 3};
      const a4 = {a: 4};
      const a5 = {a: 5};
      const a6 = {a: 6};

      const ops2 = [
        o, a1, a2,
        0, a3, a4,
        2, a5,
        -1, a6
      ];
      const {nodes, rows, branches} = buildTree(ops2);
      assertEquals([o, a1, a2, a3, a4, a5, a6], nodes);
      assertEquals([[o, a1, a2], [0, a3, a4, a6], [2, a5]], rows);
      assertEquals([[o, a1, a2], [o, a3, a4, a6], [o, a1, a2, a5]], branches);

      // 3: Same as ops but with more interspersed integers
      const ops3 = [
        {handler: 'log'},
        {handler: 'inc'},
        {handler: 'assert', a: 1, b: 2},
        {handler: 'inc'},
        {handler: 'assert', a: 2, b: 4},
        2,
        {a: null},
        {handler: 'assert', a: 0},
        {handler: 'sum', a: 1, b: 2},
        {handler: 'assert', a: 3},
        {a: null},
        {a: 3},
        {a: 2},
        {handler: 'assert', a: 5},
        {handler: 'mul', a: 10},
        {handler: 'assert', a: 50},
        {handler: 'log'},
      ];
      const {branches: branches3, allBranchesReachable, residues, summary} = buildTree(ops3);
      allBranchesReachable({handlers: {log, inc, sum, mul, assert}});
      if (DEBUG) console.log('branches3', branches3, 'residues', residues, 'summary', summary);
    }

    // A much simpler combine not for production use - just playing with some ideas.
    function combine(a, b) {
      // this convention implies b "acts on" a, in this case by 'zeroing a out' when b is null.
      // we can't zero out a boolean without introducing null, so we toggle it instead.
      // combine is not associative, but it does have an identity and a zero.
      if (typeof a === 'undefined' || a === null) return b; // 'something is better than nothing'
      if (typeof b === 'undefined') return a; // 'avoid special cases and let nothing compose as a noop'
      if (b === null) { // 'use null as a signal to set a type-dependent zero
        if (Array.isArray(a))       return [];
        if (typeof a === 'object')  return {};
        if (typeof a === 'number')  return  0;
        if (typeof a === 'string')  return '';
        if (typeof a === 'boolean') return !a;
        if (typeof a === 'function') return () => {};
      }

      // If both args are arrays, combine every element - concatenation is also a reasonable rule
      if (Array.isArray(a) && Array.isArray(b)) {
        return a.map((ai, i) => combine(ai, b[i]));
      }

      // If both args are plain objects, combine every shared key, and add the non-shared keys, too.
      if (isObj(a) && isObj(b)) {
        if (isCore(a) && isMsg(b)){
          if (!isHandler(a.handlers[b.handler])) throw `Unable to find valid handler ${b.handler} in core ${a}`;
          let result = a.handlers[b.handler].handle(a, b);
          if (!Array.isArray(result)) result = [result];
          result.every(obj => a = combine(a, obj));
          return a;
        }
        const result = {};
        for (const key of Object.keys(a)) {
          result[key] = a[key];
          if (key in b) {
            result[key] = combine(a[key], b[key]);
          }
        }
        for (const key of Object.keys(b)) {
          if (!(key in a)) {
            result[key] = b[key];
          }
        }
        return result;
      }

      if (typeof a === 'string' && typeof b === 'string') return b;
      if (typeof a === 'boolean' && typeof b === 'boolean') return b;
      if (typeof a === 'number' && typeof b === 'number') return a + b;

      throw `unable to combine ${a} and ${b}`
    }

    // Take an array with sprinkled integers and turn it into a tree of related elements
    function buildTree(arr) {
      const rows = [[]];
      const nodes = [];
      let currRow = rows[0];

      arr.every(d => {
        if (isNum(d) && d >= 0 ){
          // Positive numbers mean the target is a node
          if (d >= nodes.length) throw 'invalid parent node ' + d;
          currRow = [d];
          rows.push(currRow);
        } else if(isNum(d) && d < 0) {
          // Negative numbers means the target is a row.
          if (-d >= rows.length) throw 'invalid row ' + d;
          currRow = rows[-d];
        } else {
          // Non-numbers are input (especially objects)
          let parent = peek(currRow);
          d.parent = isNum(parent) ? nodes[parent] : parent;
          currRow.push(d);
          nodes.push(d);
        }
        return true;
      });

      // Build up each branch array by walking up to root from the tip
      const branches = () => rows.map(row => {
        let node = peek(row);
        const result = [node];
        while (node.parent){
          node = node.parent;
          result.unshift(node)
        }
        return result;
      });

      // Return true if the given core can reach all points on all branches of this tree.
      const allBranchesReachable = core => branches().every((branch, branchi) => {
        let state = core; // reset the core before every branch
        return branch.every((op, opi) => {
          try {
            state = combine(state, op);
            return true;
          } catch (e) {
            console.error(`cannot combine op ${JSON.stringify(op)} at branch ${branchi} and op i ${opi} ${JSON.stringify(state)}`);
            throw e;
          }
        });
      });

      // Map each branch to a residue by reducing the branch under combine
      // This can be highly optimized by storing residue at the branch tips. Don't worry about it now.
      const residues = (reduction=combine, start={}) => branches().map(branch => branch.reduce(reduction, start));

      // Finally, we can combine all the residues into a summary, by default using combine for both reductions
      const summary = (r1=combine, r2=combine, s1={}, s2={}) => residues(r1, s1).reduce(r2, s2);

      return {rows, nodes, branches: branches(), allBranchesReachable, residues: residues(), summary: summary()};
    }

  </script>
</div>
</body>
</html>
