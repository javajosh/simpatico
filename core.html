<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="description" content="Title">
	<meta name="keywords" content="JavaScript, ES6, functional, simpatico, minimalist, web verite">
	<meta name="author" content="Josh Rehman">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link id="favicon" rel="icon" type="image/png" href="white.png" />
	<meta id="refresh" http-equiv="refresh" content="2">
	<title>Core.js</title>
  <link rel="stylesheet" type="text/css" href="tufte.css">
</head>
<body>
	<h1>Core.js</h1>
	<p>Josh Rehman <i>2020-11-11</i></p>
	<p>deps: <code>core.js</code></p>
	<button onclick="window.stop()">Stop 2s Refresh</button>


	<script>
    // Walk up the location path, checking for the resource, returning that one when you find it.
    // Alternatively (and arguably more performantly) you can serve up resources in this way.
    // From the perspective of the programmer, adding a resource at a top level makes it
    // present in all descendant folders. At the command line, this would look like a strange "mode"
    // in which you accumulate a stack of useful state that you can easily call upon
    // (typically some form of : fork, move, invoke, interact). This could most easily be achieved
    // with a file-watcher script that would create symbolic links in the descendent folders (and update
    // them in the case of move or delete). Interestingly, this "goes with the grain" of the unix
    // philosophy to the point where "group" can have explicit, precise meaning, as
    // describing those resources that are shared read-only with descendents, but write-only to your
    // group (and its "ancestors") in the hierarchy.
    // Is discovering a way to divide up the dishonest work of defrauding someone such that none of the
    // pieces realizes that its being used in this way, is that a valid kind of innovation?
    // This is the same moral hazard present in movies such as "Cube" (I think? It's the one where
    // the group wakes up in a cube of trapped cubes, connected



		window.onerror = e => {
		  document.getElementById('favicon').href='red.png';
		  document.body.style.backgroundColor = 'red';
		};
	</script>
	<script type="module">
    import Core from './core.js';

    const {STR: str, NUM: num, BOOL: bool, FUN: fun, OBJ: obj, ARR: arr, SAME: same, ALL: all, EXISTS: exists,
      CONTAINS:contains, assertEquals, arrEquals, assertThrows, BETWEEN: between, } = Core.asserts;
    const {cast} = Core.types;
    const {mapObject} = Core.objects;
    const {size} = Core.utils;

		str('foobar');
		num(1);
		bool(false);
		fun(()=>{});
		obj({});
		arr([]);
		between(0,10,5);
		between(0,10,'a'); //between assumes string length
		between(0,4,[1,2]);
    exists([]);
    exists({});
    exists(0);

    arrEquals([],[]);
		contains([1,3,4], 3);

		bool(cast('boolean', 'false'));
		num(cast('number', "1234"));

		all([1,1,1]);

    assertEquals({a:3,b:4}, mapObject({a:1,b:2}, ([k,v])=>([k,v+2])));

    // TODO: same() doesn't work on booleans properly, yet.
		//same([true, true]);
		//same([false, false]);
		same([1,1,1,1,1]);
    same(['a','a','a']);
    same([{}, {}, {}, {}]);

		assertEquals({a:1, b:[2,3]},{a:1, b:[2,3]});
		// TODO: make object equals() insensitive to object key order.
    // assertEquals({b:[2,3], a:1},{a:1, b:[2,3]});

		assertThrows(()=>num('1'));
		assertThrows(()=>bool('1'));
		assertThrows(()=>obj([]));
		assertThrows(()=>between(0,10,11));
		// assertThrows(()=>same([false, true]));
		assertThrows(()=>same([1,1,2]));
    assertThrows(()=>all([true, false]));
		assertThrows(()=>num(cast(TYPES.NUM, 'a')));
		assertThrows(()=>assertEquals({a:1, b:[2,3]},{a:1, b:[2,3, false]}));

    assertEquals(1, size(1));
    assertEquals(2, size([1,2]));
    assertEquals(3, size({a:1, b:2, c:3}));
    assertEquals(4, size("goat"));
    assertEquals(5, size(5));

		console.log('Tests succeeded!');
		document.getElementById('favicon').href='green.png';
	</script>
</body>
</html>
