<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Green Square</title>
</head>

<body>
  <h2>Things you can do:</h2>
  <ol>
    <li>Watch the pretty animation.</li>
    <li>Start and stop the animation with the space bar.</li>
    <li>Move around manually with the WSAD keys.</li>
    <li>Interact with the dev console; e.g. <code>combine(state, {x:10})</code>.</li>
    <li>Read the code and maybe send me a tweet @javajosh!</li>
  </ol>

  <svg id="0" width="500" height="500" viewBox="-250 -250 500 500" style="border:1px solid black" >
    <rect id="1" x="0" y="-20" width="10" height="10" fill="green" rotating="true" stepsPerRotation = "120" />
    <rect id="2" x="0" y="0" width="10" height="10" fill="blue" rotating="false" />
  </svg>

  <p>It's still not good yet. The problem is that the state (in this case the three degrees of freedom of the animation, x, y and 'rotating') isn't really bounded, and the state does not output a description of allowable bounds. It would be possible to add some ad hoc handlers, but they would end up looking more like Redux reducers because our <code>combine</code> function here is so simple and weak. It's possible to put more validation in a wide variety of places, but each of those options comes with significant drawbacks. </p>

  <script>
    // The other script tags probably won't even parse.
    if (navigator.userAgent.indexOf("MSIE") > -1) 
      window.alert('IE is not supported.');
  </script>
  <script src="utils.js"></script>
  <script>
  'use strict';

  install(window, assertions);

  // Convention: define references to declared markup as constants.
  // const BOARD = document.getElementById('0');
  const SQUARE = document.getElementById('1');
  // Note that the values don't really matter, but the types should be accurate.
  const state = {x: 0, y: 0, rotating: true, scale:1, stepsPerRotation: 120};
  // const board = {width: 500, height: 500};

  gather(SQUARE, state);
  // gather(BOARD, board);


  // A generator function that returns a rotating vector
  function* circlePath(stepsPerRotation = 60, theta = 0){
    while (true) {
      theta += 2 * Math.PI / stepsPerRotation;
      yield [Math.cos(theta), Math.sin(theta)];
    }
  }

  const path = circlePath(state.stepsPerRotation);

  // The central loop, always running.
  const animate = ()=>{
  	if (state.rotating){
	    let [dx, dy] = path.next().value;
	    let c = state.scale;
	    [dx, dy] = [dx * c, dy * c];
	    combine(state, {x:dx, y:dy});
  	}
  	scatter(SQUARE, state);
  	requestAnimationFrame(animate);
  }

  // Give the user something to do with the keyboard.
	const inputs = {
		'd' : {x:10},
    'a' : {x:-10},
  	'w' : {y:-10},
    's' : {y:10},
    ' ' : {rotating: 'false'},
    'ArrowLeft' : {scale: 0.1},
    'ArrowRight' : {scale: -0.1},
	};

  document.body.addEventListener('keydown', e => {
  	const input = inputs[e.key];
  	combine(state, input);
    scatter(SQUARE, state);
  });

  animate();

  </script>
</body>

</html>
