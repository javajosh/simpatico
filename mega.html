<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="keywords" content="JavaScript, ES6, HTML5 functional, simpatico, minimalist, web verite">
  <meta name="author" content="Josh Rehman">
  <link id="favicon" rel="icon" type="image/svg"
        href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg'
        width='24' height='24' viewBox='0 0 24 24' fill='none'
        stroke='orange' stroke-width='2'%3E
          %3Ccircle cx='12' cy='12' r='10' /%3E
        %3C/svg%3E"/>
  <title>Simpatico</title>
  <!-- With the above we thank our progenitors, the inventors of TCP/IP, HTTTP, the maintainers of browsers,
   and web servers. -->
  <!-- We thank the inventors of cloud computing for making scalable designs easier to iterate on.
       We thank the authors of Kubernetes for attacking the problem of orchestration from first principles.
       I just noticed that one computer is now very fast and capable, and I bet I could service
       100k simultaneous clients from a single physical server.

       The client is a single html file, this file, written in a peculiar way.
       For one thing, keep an eye on where we are, vertically, in the source file.
       It's early yet.

       Our global styles are very generic, optimized for a good looking written document. No reset,
       just some typographic and layout mode stuff.
   -->
  <style>
    html {
      box-sizing: border-box;
      font-size: 16px;
      line-height: 1.5em;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, "Helvetica Neue", Helvetica, sans-serif;
    }

    *, *:before, *:after {
      box-sizing: inherit;
    }

    img, svg {
      max-width: 100%;
      height: auto;
      border: 1px solid black;
    }

    pre{
      color: #78A960;
      background-color: #1e1f20;
      overflow-x: auto;
    }
    code{
      color: #78A960;
    }


    @media (prefers-color-scheme: dark) {
      html{
        color: #ffca28;
        background-color: #1e1f20;
      }

      a {
        color: aliceblue;
      }

      a:link{
        color: aliceblue;
      }

      a:visited{
        color: #1f7199;
      }

      pre{
        color: #78A960;
      }

    }

  </style>
</head>
<body>
<!-- Finally, the content. For one thing I want to write naturally. -->

<h1>Simpatico Screenshot Sequence Tool</h1>
<h2>Concept</h2>
  <p>A new Chrome Browser Extension that records sequences of screenshots of webapps, and a service that
    that shares and annotates those sequences. What you have produced is a navigable 2D map of
    screenshots that can itself be considered a true and complete map of an application's characteristic
    reachable states. This map is presented to the user as a SPA that can zoom in and out of the arrangement.
    Image data hosted on S3, the interactive sequence reader is sharable (plop it in Confluence or Jira or Github!)
    Somewhat uniquely data for every domain is stored very simply, as a file of textual objects, filename rotated daily.
    It is useful to ignore rotation and assume one file per customer for the life of the relationship.
    (Who knows, maybe this is possible)
  </p>
At the top level, I guess we'll break it up by day - movements within, and additions, to the current state of your
browser. This can be simple, such as when you're building some experience for your friends. That experience is local,
for your eyes only. It lives on your device, only your device. You can share it that way, and see your friends within
your running browser tabs, get a sense for "where they are" in the experience. This also assumes either in-person
or real-time voice/face connection so that they can express, and you can detect, whether they are enjoying the experience.
Our stories can be hard to tell. They can be harder to listen to, if they are boring, if they don't pay off. Plenty
of people feel they have a unique and valuable perspective on the world - but how many are right about that? We may share
an interest, for example in fatherhood. Raising children with, or without, the mother. For those with marital trauma, it is
too easy to slip into the myriad painful branches of that broken world. (Some people are into emo, and the shadow.
So find them. Be weirdo friends.

Canonically a Simpatico application is the process reached by first instantiating a Simpatico shell at https://simpatico.io.
The browser code, at that point, should be considered as being in a state accurately described by feeding the shell a
list of inputs. We allow for appending to that list of inputs, which advances the state. The default list should be a
thing of beauty, something to convince you that simpatico is worth checking out.

We tentatively specify a shell that includes an interactive tutorial, where the entire interface is taken over by
a 2000x2000/2.0x2.0 unit circle SVG image in a webpage. We add shapes to it. In particular, we make a neat 2D array of
non-overlapping squares and we can number the squares from 0. Layout is achieved by adding to the same row, unless
there is already a child, in which case place a new row at the end. Picking out related squares should be straight
forward. An additional area can be used to compute the reduction of this tree at any node. If the process isn't
halted, then this reduction takes the form of a collapsible template, the union of all possible
valid inputs for the process. Which at the beginning is just the empty object, and over time is interleaved numbers
and objects, and that describes the building up of the basic tools and supplies we'll want to build our projects.

While it is convenient, and elegant, to describe a rehman tree all in one place, in memory, the "shape"
is general enough that you can describe one in a wide variety of ways. Consider an http server process that
simply generates a new html based on input from the old one. Let us say a POST'ed form. So, you have a site
whose content is a list of inputs recieved in the past, plus a reduction over those inputs that yields some useful thing,
perhaps a form request for more input.

"I don't want to quit now. Do you?"

So you create these chains, these sequences of input, and you demonstrate how yes, they can be stored
locally, in the browser. And yes, you can invite people to "browse" within your private, in browser space.
What I imagine are lurid travelogues; perhaps heartfelt horror stories about divorce or death. Or perhaps just
pictures of loved ones, like kids, or pets. But we have this concept of building your own space, inviting people into
it, one at a time. And also of course visiting other people's spaces that they've built. It should be filled with the
things that move you; the ideas that inspire you; the music that sounds good; the people you're enjoying the most in
your life. It's contents come from everywhere else, but you organize those components into a work of art.

Shapes that move. That sync with the music. That tell a story. And you narrate, and maybe answer questions.
Maybe this becomes a shared artifact that you'll treasure together.
What if you don't want to hear it, at least not right now?
What if you wouldn't want to hear it, even from your closest family?
What if he doesn't take the hint? What if you cut him off and never speak to him again?

You know who wants to hear this story? Literally everyone else with a similar story.
And you want to feel like you're not alone, because you're not.
So take your stories that your people are allergic to but you need to tell, but tell them to the right group.
Get support for your hurts. And there may be enough of us to drive some law changes.

Build out a photo shrine to your kids. Why not? Go ahead and indulge yourself.
Write an essay about watching your oldest learn how to crawl, and how marvelous it was, how tenacious she was.
Build out a detailed timeline of events that happened in the divorce, and provide detailed an accurate
visual aids for any discussion.

No one believes me, and no-one really cares. But start with content from elsewhere in the browser,
like Instagram, Facebook, Twitter, Google Photos etc. from your own and supporting accounts to produce a
bouquet of curated content, with the focus on objectively good things, and a section for outrageously bad things.
each piece of content begins a new row, and new messages are added to the row, moving it to its final place in the composition.
It's a well-defined particle system.
It even has a straight-forward DOM representation, as a list of g.transform="X" > image where
the transform is the final position computed by the row.


What do you do when your life is invention, filled with the thrill of discovery?
To ship the mountain range you shipped the mountain maker and a script.
To ship the new unit you shipped the unit maker and a script.
To ship the new user interface you shipped the interface builder and a script.






<h2>Demo</h2>
  <p>Try this interactive demo that lets you create a tree of related images.</p>
  <p>We describe each image as a list of transforms applied to a well-known starting point, the story book.</p>
  <p>The panel on the right.</p>
  <p>The panel on the left accumulates, records, integrates the images you pick with the right panel.</p>
  <p>The left panel is the navigator, zoomer, mover around the tree, and the right panel is just an input picker.</p>
  <p>An important component of the story book is a JSON object builder which accumulates strings or objects.
  With strings we alternate between label and value. We try to 'upgrade' the value by applying JSON parse.</p>
<p>The shared service must support multiple domains, so account serves as the root of the service.</p>
<p>The addition of a customer and joyful and a slight amount of work to integrate them is acceptable.</p>
<h2>Our customers are cool and have great taste. Know them.</h2>
<ol>
  <li>Blah blah. Our first customer, CTO of cool-ass-startup.com</li>
  <li>Blah. Our Nth customer, CTO of startup.com</li>
</ol>
<h2>Share about your users</h2>
<ol>
  <li>What a great tool! It's really revolutionized our discussions and helped us ground the discussion in reality.</li>
  <li>Our team was able to finally understand the scope of the application after they comprehensively mapped it's visible states using this amazing tool.</li>
</ol>
<h2>Share about your dev team and your business plan</h2>
<h2>Implementation</h2>
<p>A key element of our success will be to keep costs down, which means minimal infrastructure and complexity</p>
<p>Keeping things to a single server process simplifies things a lot, if we can do it. For us the server's main job
will be to serve sequence resources, which are URLs that describe a user/domain/position triple, plus the backing store for the images.</p>
<p>I suggest that the simplest server is one  </p>
<p>There is a generous free tier for individuals.</p>
<p>Companies that this this artifact is crucial to measure and could help with the software description and development process
then it's worth $10/mo/user. My goal is to turn this into something worth $500/mo/user so that $10 won't hurt at all.</p>
<p>So basically everyone is adding to the same list all at once, but messages are sorted by account first</p>
<p>Measurement, threshold and throttle. And the impact of current payment status on these.</p>
<p>It is the sum total of paying customers and what they pay you for your service.</p>
<p>And to be sure some of that money goes to pay for commodity services like hosting.</p>
<p>It can go to pay for all the other services a business needs to grow and thrive, like programming, presenting to conferences, etc..</p>
<p>I'd like to keep everything open-source. This includes the html shell that specializes the browser into a container into which you can
record your images, and combine them not only statically in source, but dynamically at runtime, with support for ad hoc user interaction.</p>
<p>Paying corporate customers get subdomains that map to a user account subdirectory. This user account corresponds to actual, active control
over the account as a whole, including the management of other (virtual) accounts and their various types. In fact this is the owner of the company
that begins a subscription arrangement. Your devs will love you. Your product people will love you. Production is going to be this box
and those accounts are your customers. Their building up accounts. Those accounts contribute to the sequences. Many others look at, interact with and annotate those sequences.</p>
<p>These sequences serve as real-time interactive tools to explain how things are going wrong, or how we want them to go in the future.</p>

<h2>Needed</h2>
<ol>
  <li>Chrome Browser Extension. Locally developed and installed through Dev Tools. A writer to either localstorage or to a local server.</li>
  <li>Local server. A place to store and share the snaps, and a reader to explore them and their relationships.
  Each individual's message is added to the context of one shared set of sequences for the entire company.</li>
  <li>Not all messages are public. person/device/browser/url/account/activity</li>
  <li>Usually you'd be adding things to your own activities, like adding snaps and commentary.</li>
  <li>Sometimes you'll want to collab on a sequence. In which case ownership may be shared.</li>
  <li>End users may be able to take a sequence of snapshots and submit it with any bug report.</li>
</ol>

<h2></h2>
<div id="content">
  <h1 id="title">Simpatico</h1>
  <p>
    <i id="author">Josh Rehman</i>
    <i id="written">2022</i>
    started: <i id="started">0</i>
  </p>
  <button onclick="log(JSONParseDOM("content"))">add(onclick+above)</button>

  <script>
    function parse(maybeJsonString){
      try {
        return JSON.parse(maybeJsonString);
      } catch {
        return maybeJsonString;
      }
    }
    const root = {"content": extractObjectFromDom(document.getElementById("content"))}
    function JSONParseDOM(domNode) {
      const result = {};
      const key = domNode.getAttribute("id");
      if (!exists(key)) return null;

      // The key exists, so now lets compute a value.
      // 3 possibilities exist:
      // no children. check innerText. if string value is JSONParsable return the parsed object, string otherwise. return {key:value}
      // with children. ignore innerText and return {key: combine(children.map(child->{child.id:child.innerText}}
      // this node has children, so has a vector (object) value,
      // If there are are child dom nodes, then the value is an object concatenation of those objects
      const domIdChildren = domNode.children.filter(child => child.hasAttribute("id"));
      const idEntries = domIdChildren.map(child => extractObjectFromDom(child)).map()
      if (domIdChildren.length === 0) {
        // No DOM kids so process innerText, attempting JSON parse

      }
      if (!exists(id)) return null;
      const value = domNode.innerText;
      const result = {};
      result[id] = value;
      //If innerText can be parsed as JSON, then replace string value with the parsed value.
      //Otherwise leave the result[id] string the way it was.
      try {
        result[id] = JSON.parse(value);
      } catch {
        return value;
      }
      // Find all children of this domNode that themselves have id attributes.
      // Loop over those and create an object entry with key = to dom.id.value and value = dom.id.innerText.
      domNode.children.forEach(childNode => {
        const key = childNode.getAttribute("id");
        if (key){
          const value = extractObjectFromDom(childNode, result); //recurse
          result[key] = value;
        }


        if (value)
        result[key] = value;
        return result;
      });
      return result;
    }
    function add(){

    }
  </script>

  <h2>A dialog between alice and bob</h2>
  <ol id="dialog">
    <li><b>alice</b>: hey bob, i <i>need</i> a favor.
    <li><b>bob</b>: hey alice. sure, what do you need?
    <li><b>alice</b>: can you buy me a new car? Maybe a Tesla?
  </ol>
  <div id="scenario">
    <input type="range" id="row" name="scenario" min="-3" max="0" value="0" oninput="bind(1*this.value)">
    <label for="row">Scenario</label>
  </div>
  <form action="#" onsubmit="return false">
    <input id="character" type="text">
    <input id="line" type="text">
    <button onclick="bind([$('#character').value, $('#line').value])">Add</button>
  </form>

</div>
<!-- Use code-folding in your editor -->
<script id="core">
  const now = a => a ? Date.now() - a : Date.now()
  const log = console.log.bind(console)
  const debug = console.debug.bind(console)
  const info = console.info.bind(console)
  const warn = console.warn.bind(console)
  const err = console.error.bind(console)

  const error = msg => {throw new Error(msg)}
  const assert = (truthy, msg) => !!truthy ? true : error(msg)

  const assertThrows = fn => {
    assert(typeof fn === 'function', `assertThrows must take a function argument instead got ${getType(fn)}`);
    let throws = false, result;
    try { result = fn() } catch (e) { throws = true }
    assert(throws, `Expected fn to throw, but it didn't and returned [${tryToStringify(result)}]`);
  };

  const tryToStringify = a => {
    if (typeof a !== 'object') return a;
    let result = '<Circular>';
    try{ result = JSON.stringify(a); } catch (ignored) {}
    return result;
  };

  const hasProp = (obj, prop) => obj.hasOwnProperty(prop)
  const getProp = (obj, prop, defaultValue = null) => hasProp(obj, prop) ? obj[prop] : defaultValue;
  const propType = (obj, prop) => getType(obj[prop])
  // noinspection JSCheckFunctionSignatures
  const mapObject = (a,fn) => Object.fromEntries(Object.entries(a).map(fn)) // fn([k,v]) => [k2,v2]
  const equals = (a,b) => typeof a === 'object' ? tryToStringify(a) === tryToStringify(b) : a === b; //needs work
  const arrEquals = (a,b) =>
    as.arr(a) && as.arr(b) && a.length === b.length &&
    a.map((v,i) => v === b[i]).reduce(and, true);

  const assertEquals = (actual, expected, msg = '') =>
    assert(equals(actual, expected), `actual is ${tryToStringify(actual)} but expected ${tryToStringify(expected)}. ${msg}`)

  // Functional logic
  const and = (a,b) => !!a && !!b
  const or = (a,b) => !!a || !!b

  // Higher order functions
  const identity = a => a
  const curryLeft = (f, a) => b => f(a,b) //left to right
  const curryRight = (f, a) => b => f(b,a) //right to left
  const curry = curryLeft
  const compose = (f, g) => a => g(f(a))
  const compose2 = (f, g) => a => f(g(a))

  // It is tempting to add peek like this, but it's in bad taste. So use the functional version:
  // Array.prototype.peek = function(){return this.length > 0 ? this[this.length-1] : null};
  const peek = (arr, defaultValue = null) => arr.length ? arr[arr.length - 1] : defaultValue
  const push = (arr, a) => {arr.push(a); return arr} //mutating

  // Copies good for arrays
  const copy1 = a => [...a]
  const copy2 = a => a.slice()
  // Copies maybe good for objects
  const copy3 = a => JSON.parse(JSON.stringify(a)) //sadly unstable key order
  const copy4 = a => mapObject(a, identity); //shallow copy, but might be extensible.
  const copy = copy3; //TODO: find or make a better copy.


  // Types
  const TYPES = {
    // These are the 7 elementary JS types, excluding void and symbol (which I haven't had a use for)
    UNDEF: "undefined",
    NUL: "null",
    STR: "string",
    NUM: "number",
    BOOL: "boolean",
    FUN: "function",
    OBJ: "object",

    // Useful compound built in types
    ARR: "array",
    ANY: "any",
    ELT: "element", //only in browsers

    // Simpatico types
    HANDLER: "handle", //a handler has a handle function
    MSG: "msg", //a message has a msg attr
  };

  const getType = (a) => {
    const {UNDEF,NUL,STR,FUN,OBJ,ARR,ELT,HANDLER,MSG} = TYPES;
    let t = typeof a;
    if (t !== OBJ)        return t;

    if (a === null)       return NUL;
    if (a === undefined)  return UNDEF;
    if (Array.isArray(a)) return ARR;

    if (
      typeof window  !== 'undefined' &&
      typeof Element !== 'undefined' &&
      a instanceof Element
    )  return ELT;

    // Simpatico types
    if (propType(a, HANDLER) === FUN) return HANDLER;
    if (propType(a, MSG) === STR)     return MSG;
    // Note: properly typing the CORE type messes up the message cascade

    return OBJ;
  }

  const size = (a) => {
    const t = getType(a);
    const {UNDEF,NUL,NUM,STR,FUN,OBJ,ARR,ELT,HANDLER,MSG} = TYPES;
    switch (t){
      case NUM:
        return a;
      case STR: // todo: deal with unusual encodings
        return a.length;
      case FUN: // fun.length returns argument cardinality
      case ARR:
        return a.length;
      case HANDLER:
      case MSG:
      case OBJ:
        return Object.keys(a).length;
      case UNDEF:
      case NUL:
      case ELT:
        return 0;
    }
  };

  // Cast a string into another type - only string, number and boolean supported, currently.
  // Mainly supports the case when JS returns NaN when parsing a string
  const cast = (type, str) => {
    const {STR,NUM,BOOL} = TYPES;
    assert(getType(str) === 'string', `string cast value required; called with [${getType(str)}]`);

    switch (type) {
      case STR:
        return str;
      case NUM:
        const result = 1 * str;
        if (Number.isNaN(result)) throw new Error(`Cannot convert ${str} into a number`);
        return result;
      case BOOL:
        return (str === 'true' || str === '1' || str === 'yes');
      default:
        throw `casting to type ${type} not supported`
    }
  };


  // is looks something like {NUL: a => getType(a) === NUL, STR: a => getType(a) === STR ...}
  // ASSERT wraps with an assertion  {NUL: (a, msg) => assert(getType(a) === NUL, msg), STR: (a,msg) => assert(getType(a) === STR, msg)}
  const is = mapObject(TYPES,([k, v]) =>
    [k.toLowerCase(), a => getType(a) === v]
  )
  is.int = a => is.num(a) && (a % 1 === 0)
  is.natural = a => is.int(a) && a > 0
  is.exists = a => (typeof a !== 'undefined') && (a !== null)
  is.between = (lo, hi, a) =>
    size(lo) <= size(hi) &&
    size(lo) <= size(a) &&
    size(hi) >= size(a);

  is.t = () => true
  is.f = () => false
  // Arrays
  is.all = arr => as.arr(arr) && arr.reduce(and, true)
  is.any = arr => as.arr(arr) && arr.reduce(or, false)

  // It would be nice if this was expressible as arr.reduce(equals, true), but I couldn't get it to work.
  // Also, this code is probably a lot more performant.
  is.same = (arr) => {
    as.arr(arr);
    let prev = arr[0], curr;
    for(let i = 1; i < arr.length; i++){
      curr = arr[i];
      if (!equals(curr, prev)){
        return false;
      }
    }
    return true;
  }
  is.contains = (arr, a) => as.arr(arr) && arr.includes(a);
  is.excludes = (arr, a) => !is.contains(arr, a);
  is.arrEquals = arrEquals;

  // This is awkward because we have to guess the cardinality of the predicate.
  // Another reason why the more straight-forward form is probably better.
  const as = mapObject(is,([k,v]) =>
    [k, (a, b, c, d) => assert(v(a,b,c), `expected ${k} but got ${getType(a)}`)]
  );

  // A simple PRNG inside the browser.
  // Note that every call increments state exactly once.
  // Q: convert this into a generator function?
  function RNG(seed) {
    // A simple seedable RNG based on GCC's constants
    // https://en.wikipedia.org/wiki/Linear_congruential_generator
    this.m = 0x80000000; // 2**31;
    this.a = 1103515245;
    this.c = 12345;
    this.state = seed ? seed : Math.floor(Math.random() * (this.m - 1));
  }
  RNG.prototype.nextInt = function () {
    this.state = (this.a * this.state + this.c) % this.m;
    return this.state;
  }
  RNG.prototype.nextFloat = function () {
    // returns in range [0,1]
    return this.nextInt() / (this.m - 1);
  }
  RNG.prototype.nextRange = function (start, end) {
    // returns in range [start, end): including start, excluding end
    // can't modulo nextInt because of weak randomness in lower bits
    const rangeSize = end - start;
    const randomUnder1 = this.nextInt() / this.m;
    return start + Math.floor(randomUnder1 * rangeSize);
  }
  RNG.prototype.choice = function (arr) {
    return arr[this.nextRange(0, arr.length)];
  }
  // Fisher-Yates shuffle using ES6 swap
  // mutates the argument to save space!
  const shuffle = (arr, mutate = true) => {
    as.arr(arr);
    if (arr.length < 2) return arr;
    arr = mutate ? arr : [...arr];
    let right, left, {floor, random} = Math;
    for (right = arr.length - 1; right > 0; right--) {
      left = floor(random() * (right + 1));
      [arr[left], arr[right]] = [arr[right], arr[left]];
    }
    return arr;
  }
</script>
<script id="friendly">
  /**
   *  Validate an object against a pattern obj.
   *
   *  Special cases:
   *    value != object => nothing passes (return pattern)
   *    pattern = null => nothing passes (return {})
   *    pattern = {} => everything passes (return undefined)
   *
   *  Usage as a straight boolean is confusing since !validate() would actually mean it passed.
   *  Perhaps it needs a rename to "failures" and then it would make more sense.
   *
   * @param patternObj
   * @param valueObj
   * @returns {{}|undefined|*} undefined if the object passes; an object describing the failure if it fails.
   */
  const validate = (patternObj, valueObj) => {
    //gotcha: do not use getType predicate because handler !== object, etc
    const isObjecty = a => is.obj(a) || is.msg(a)
    if (!isObjecty(valueObj)) return patternObj;
    if (patternObj === null) return {};
    if (patternObj === {}) return undefined;

    assert(isObjecty(patternObj), `pattern must be an object but was ${tryToStringify(patternObj)}`);

    const result = {};
    let objPass = true;

    for (const [patternKey, patternValue] of Object.entries(patternObj)) {
      const value = valueObj[patternKey];
      let pass = true;
      let failReasons = undefined;

      if (is.obj(patternValue)) {
        failReasons = validate(patternValue, value); //recurse
      } else {
        failReasons = checkValue(patternValue, value); //normal case
      }

      pass = is.undef(failReasons);
      if (!pass) {
        result[patternKey] = failReasons;
      }
      objPass = objPass && pass;
    }
    return objPass ? undefined : result;
  };

  /**
   * This is an internal method exported only to support testing. but it checks a value against an array of predicates.
   * This function is the one you want to change if you want to add new predicates or features to the system.
   *
   * @param predArray
   * @param value
   * @returns {undefined|*} Undefined (falsy) if pass - like the Unix convention. If there's a problem, return it.
   */
  const checkValue = (predArray, value) => {
    if (!is.arr(predArray)){
      return value === predArray ? undefined : ["equals", predArray];
    }

    const failedPreds = [];
    let pass = true;
    let allPass = true;

    // Loop through the predicates.
    for (let i = 0; i < predArray.length; i++) {
      let pred = predArray[i].toLowerCase(); // case of preds doesn't matter

      if (pred === "between") {
        const lo = predArray[i + 1];
        const hi = predArray[i + 2];
        pass = is.between(lo, hi, size(value));
        i += 2;
        if (!pass) {
          failedPreds.push(pred, lo, hi);
        }
      } else if (pred === "optional") {
        //optional means we skip if it's missing
        if (is.undef(value)) {
          return undefined;
        }
      } else {
        // You can call any predicate by name - typically this will be a type check
        pass = is[pred](value);
        if (!pass) failedPreds.push(pred);
      }
      allPass = allPass && pass;
    }
    return allPass ? undefined : failedPreds;
  };

</script>
<script id="combine">
  const combine = (target, msg, rules = getRules()) => {
    const {NUL, FUN, ARR, ANY} = TYPES;
    let ttarget = getType(target);
    let tmsg = getType(msg);

    // In some cases we erase type (set to "ANY")
    // This saves us from repetitive rule writing
    if (ttarget === NUL) {
      tmsg = ANY;
    } else if (tmsg !== NUL) {
      // Functions just invoke, so erase the counter type
      if (tmsg === FUN) ttarget = ANY;
      else if (ttarget === FUN && tmsg !== NUL) tmsg = ANY;
      // Arrays push, so erase the message type
      else if (ttarget === ARR && tmsg !== ARR) tmsg = ANY;
    }

    // Lookup the rule, throw if you can't find it.
    const ruleKey = ttarget + tmsg;
    const rule = rules[ruleKey];
    if (!rule) {
      throw `rule not found for target=${tryToStringify(target)} msg=${tryToStringify(msg)} ruleKey=${ruleKey}`;
    }

    // Invoke the rule and return
    // debug('combine()=>', 'rule:', ruleKey, 'target:', target, 'msg:', msg );
    const debugObject = {
      ruleKey: ruleKey,
      target: tryToStringify(target),
      msg: tryToStringify(msg),
    }
    // debug(debugObject);
    const result = rule(target, msg);
    debugObject.result = tryToStringify(result);
    debug(debugObject);

    return result;
  }

  const getRules = () => {
    /**
     * Rules for combining things. The first arg is the target, second the message
     proceed from the "natural" types to the synthetic types introduced by Simpatico.

     Docs Comments on the basic rules:
     Null means "clear". For booleans, null means "toggle".
     We cannot push null to an array because that will clear the array.
     Arrays immutable concat (this is one way to get a null in there!)
     */
    const {UNDEF, NUL, STR, NUM, BOOL, FUN, OBJ, ARR, ELT, ANY, CORE, HANDLER, MSG} = TYPES;
    const rules = {};
    rules[NUL + ANY] = (_, b) => b;

    rules[STR + STR] = (_, b) => b;
    rules[STR + NUL] = () => '';

    rules[NUM + NUM] = (a, b) => a + b;
    rules[NUM + STR] = (_, b) => cast(NUM, b);
    rules[NUM + NUL] = () => 0;

    rules[BOOL + BOOL] = (a, b) => b;
    rules[BOOL + STR] = (_, b) => cast(BOOL, b);
    rules[BOOL + NUL] = (a, _) => !a;

    rules[ARR + ARR] = (a, b) => a.concat(b);
    rules[ARR + ANY] = (a, b) => [...a, b];
    rules[ARR + NUL] = () => [];

    rules[FUN + NUL] = (a, b) => null;
    rules[FUN + ANY] = (a, b) => a(b);
    rules[ANY + FUN] = (a, b) => b(a);

    //rules[ELT + OBJ] = (a, b) => scatter(a, b);
    //rules[OBJ + ELT] = (a, b) => gather(a, b);

    rules[OBJ + OBJ] = (a, b) => {
      // B is defensively copied, mutated and returned, not A!
      b = Object.assign({}, b);
      for (const prop in a) {
        b[prop] = b.hasOwnProperty(prop) ?
          combine(a[prop], b[prop]) : //recurse
          a[prop];
      }
      return b;
    };

    //Gotcha: handler invocation does some limited mutation!
    //mutation: core.msgs will get a push,
    //mutation: msg will get an id, time and children
    //mutation: all results will get the id of the parent
    rules[OBJ + MSG] = (core, msg) => {
      // World event - defensively copy because we mutate
      const isWorldEvent = is.undef(msg.parent);
      if (isWorldEvent) msg = {time: now(), ...msg};
      msg = {id: core.msgs.length, ...msg};
      core.msgs.push(msg);

      //Find the named handler
      const handler = core.handlers[msg[TYPES.MSG]];
      assert(handler, `handler not found for msg ${tryToStringify(msg)}`);

      // Invoke the handler.
      // Results should always be an array, so help sloppy handlers
      let results = handler[TYPES.HANDLER](core, msg);
      if (!is.arr(results)) results = [results];

      // Build up some more info about the message cascade.
      msg.children = results;

      //Recurse for each result
      for (const result of results) {
        // Store the id of the parent to avoid cycles that stop stringification
        if (is.obj(result)) result.parent = msg.id;
        core = combine(core, result); //recurse, generates the message cascade.
      }
      return core;
    };

    //handler registration
    rules[OBJ + HANDLER] = (core, handler) => {
      core = combine(core, {handlers: {}, msgs: []});
      core.handlers[handler.name] = handler;
      return core;
    };
    return rules;
  };

  // Convenience functions that wrap combine
  // Note that the intuitive reduction (arr.reduce(combine, residue)) doesn't work for some unknown reason.
  const combineAll = (arr, residue = {}) => {
    for (let i = 0; i < arr.length; i++) {
      residue = combine(residue, arr[i]);
    }
    return residue;
  };

  const combineAllArgs = (...args) => combineAll(Array.from(args));
</script>
<script id="rtree">
  const rtree = (startValue= {}, reducer = combine) => {
    const ROOT = {
      id: 0,
      time: now(),
      branch: 0,
      parent: null,
      children: [],
      value: startValue,
      residue: startValue,
    };

    const ms = [ROOT];
    const branches = [ROOT];
    let focus = 0;

    const getFocus = () => focus;
    const read = () => (focus > 0) ? ms[focus] : branches[-focus];
    const residue = () => read().residue;
    const setFocus = i => {
      as.between(-branches.length - 1, ms.length - 1 , i);
      focus = i;
      return read();
    };
    const possibleFocus = () => [-branches.length - 1, ms.length - 1 ]

    const add = (value) => {
      const parent = read();
      const residue = reducer(parent.residue, value);
      const branch = (focus <= 0) ? parent.branch : -branches.length;

      const m = {
        id: ms.length,
        time: now(),
        children: [],
        branch,
        parent,
        value,
        residue,
      };
      // TODO: check that no sibling ms have the same value.
      parent.children.push(m);

      if (branch === parent.branch){
        branches[-branch] = m;
      } else {
        focus = -branches.length;
        branches.push(m);
      }

      ms.push(m);
      return m;
    }
    return {setFocus, getFocus, read, residue, add, ms, branches, possibleFocus};
  }
</script>
<script id="app" >
  const $ = document.querySelector.bind(document);

  const render = (obj) => Object.entries(obj).map(([key, value] = entry) => {
    const elt = $('#' + key)
    if (!elt) return
    if (is.str(value))
      elt.innerHTML = value
    else if (key === 'dialog' && is.arr(value))
      elt.innerHTML = renderDialogToListString(value)
    //else if (key === 'scenario' && is.int(value))
      //elt.innerHTML = renderRangeInputString(value, state)
  });

  const renderDialogToListString = (arr) => {
    let result = "<ol>";
    for (let i = 0; i < arr.length; i++) {
      let [character, line] = Object.entries(arr[i])[0];
      result += `<li><b class="character">${character}</b>: <i class="line">${line}</i>`
    }
    result += "</ol>";
    return result;
  }
  const renderRangeInputString = (value, state) => {
    return `<input type="range" id="row" name="scenario"
        min="${state.branches.length}" max="0"
        value="${value}" oninput="bind(1*this.value)">
        <label for="row">Scenario</label>`
  }

  // Probably a good practice to "manually render" initial state into the HTML above.
  let state = rtree({
    app: "Simpatico",
    author: "Josh Rehman",
    written: "2022",
    started: now(),
    scenario: 0,
    dialog: []
  });


  const bind = (e) => {
    debug('bind entry', typeof e, e instanceof Event, e);

    if (e instanceof Event){
      //state.add(e);
    } else if (is.str(e)) { // arbitrary JSON string from dev tools.
      try {
        const input = JSON.parse(e);
        state.add(input);
      } catch (ex) {
        err(`unable to understand ${e} - threw exception ${ex}`)
      }
    } else if (is.arr(e)) { // character, line from the form.
      const [character, line] = e;
      const input = {dialog: {}};
      input.dialog[character] = line;
      debug('bind is.arr(e)', character, line, input);
      state.add(input);
    } else if (is.int(e)){ // a focus point from dev tools
      state.setFocus(e)
    } else {
      err(`unable to understand ${e} of type ${getType(e)}`)
      return;
    }
    render(state.residue());
  }
  // Row 0 is special, it describes the application
  render(state.residue());

  // The happy path, row 0
  bind(JSON.stringify({dialog: {alice:'excuse me sir, my car just broke down. can i use your phone?'}}))
  bind(JSON.stringify({dialog: {bob:'of course, come on in!'}}))
  bind(JSON.stringify({dialog: {alice:'thank you sir. what do I call you?'}}))
  bind(JSON.stringify({dialog: {bob:'the name\'s bob. pleased to meet you. what\'s your name?'}}))
  // The sad path, row 1
  bind(1);
  bind(JSON.stringify({dialog: {bob:'no. I do not let strangers use my things.'}}))
  bind(JSON.stringify({dialog: {alice:'please sir, my children are in the car. have pity sir!'}}))
  // The capitalist path, row 2
  bind(1);
  bind(JSON.stringify({dialog: {bob:'yes, but it will cost you.'}}))
  bind(JSON.stringify({dialog: {alice:'how much?'}}))
  bind(JSON.stringify({dialog: {bob:'For you darlin? 1 US American dollar.'}}))
  // The nicer capitalist path, row 3
  bind(8)
  bind(JSON.stringify({dialog: {bob:'that will be 50 cents.'}}))
</script>

</body>
</html>
