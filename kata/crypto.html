<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="keywords" content="JavaScript, ES6, functional, simpatico, minimalist, web verite">
  <meta name="author" content="javajosh">

  <!-- Begin testable.js html boilerplate; testable.js is in the same directory -->
  <link id="favicon" rel="icon" type="image/svg+xml" href="data:image/svg+xml,
  <svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1 1'>
      <rect width='1' height='1' fill='white' />
  </svg>"/>
<!--  <meta id="refresh" http-equiv="refresh" content="2">-->
  <script src="../testable.js" type="module"></script>
  <!-- End testable.js boilerplate  -->

  <title>crypto</title>
  <link rel="stylesheet" href="../style.css">
</head>
<body>
<h1>crypto</h1>
<p>javajosh <i>2023</i></p>
<div class="makeItStop"></div>

<p>
  Exercise cryptographic primitives.
  In this case use the crypto library to generate a key, encrypt a thing, then decrypt.
  Note that, at this point, we cannot save the generated keys for later use.
</p>

<script type="module">
import {generateSymmetricKey, encrypt, pack, decrypt, unpack} from './crypto.js';

  const app = async () => {
    // encrypt message
    const msg = 'Hey crypto cats!!';
    const key = await generateSymmetricKey();
    const { cipher, iv } = await encrypt(msg, key);

    // pack and transmit
    // await fetch('/secure-api', {
    //   method: 'POST',
    //   body: JSON.stringify({
    //     cipher: pack(cipher),
    //     iv: pack(iv),
    //   }),
    // })
    // retrieve
    // const response = await fetch('/secure-api').then(res => res.json())
    const fakeResponse = {
      cipher: pack(cipher),
      iv: pack(iv),
    }

    // unpack and decrypt message
    const final = await decrypt(
      unpack(fakeResponse.cipher),
      key,
      unpack(fakeResponse.iv),
    );
    console.log(final); // logs 'Hello, World!'
  }
  app();
</script>

<p>
  Let's <a href="https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto">export the key</a> so we can use it over time.
  This covered in <a href="https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/exportKey">MDN's exportKey() docs</a>
  That is, you can reuse a key you generated once over and over, potentially for communication.
</p>

<p class="aside">
  About key rotation.
  In general though we should rotate keys fairly often, even as often as once a day.
  More often than that is certainly excessive.
  Less often may even make sense, for example, once a month.
  One simply shares the new public key across all old channels.
  This is a slow "keep alive" for all of your relationships.
  It will generally not show up in your feed unless you request it.
</p>

<script type="module">
  import {generateSymmetricKey, importSymmetricKey, pack} from './crypto.js';
  import {mapObject, getProp, as} from '../core.js';

  const key = await generateSymmetricKey();


  // Export by picking a format and calling exportKey
  // On my machine only raw and jwk are supported.
  const formats = {'raw':'raw', 'pkcs8':'pkcs8', 'spki':'spki', 'jwk':'jwk'};

  // For each format try to export it in that format.
  // Measure unsupported formats
  const unsupported = {};
  let exportedKey;
  mapObject(formats, async ([_, format]) => {
    try {
      exportedKey = await window.crypto.subtle.exportKey(format, key);
    } catch (e) {//usually something like "DOMException: Operation is not supported"
      unsupported[format] = format;
    }
  });

  exportedKey = await window.crypto.subtle.exportKey('jwk', key);
  const exportedKeyPacked = pack(exportedKey);
  console.log(exportedKey, exportedKeyPacked);

  // exportedKeyPacked is something I can pass around or use as part of an address.


  await window.crypto.subtle.importKey('jwk', exportedKey,'A256GCM', true, ['encrypt', 'decrypt']);


  // The reverse is the import - feed it a string, and get back a key object
  // NB: Having some trouble getting this to work, and the error message is not helpful.
  // Feeling drained, will put aside for now and rest the brain.
  // const importKeyAsString = async (keyString="{}", format='jwk', caps=['encrypt', 'decrypt']) => {
  //   as.str(keyString) && as.str(format);
  //   const keyObject = JSON.parse(keyString);
  //   const alg = getProp(keyObject, 'alg', '');
  //   console.debug('importKeyAsString()', keyString, format, caps, alg, keyObject)
  //   return await window.crypto.subtle.importKey(
  //     format,
  //     keyObject,
  //     alg,
  //     true,
  //     caps,
  //   );
  // }
  //
  // // const testString = "{\"alg\":\"A256GCM\",\"ext\":true,\"k\":\"QeAC4fzCD1MwIyJv6IwypLUuO2MQyRwHg1yEB3scMD0\",\"key_ops\":[\"encrypt\",\"decrypt\"],\"kty\":\"oct\"}"
  // const testString = await exportKeyAsString(key);
  // console.log('testString', testString, key);
  // const testKey = importKeyAsString(testString);
  //do stuff with the key
</script>

<p>
  Consider how important it is that you protect your data.
  Consider how important it is that no-one be able to post as you online or in an app.
  Consider how little protection individuals actually have from these actions.
  We rely on vague notions of fairness and inaccurate notions of enforcement.
</p>

<script type="module">
  (() => {

    let salt;
    let iv;

    /*
    Get some key material to use as input to the deriveKey method.
    The key material is a password supplied by the user.
    */
    function getKeyMaterial() {
      const password = window.prompt("Enter your password");
      const enc = new TextEncoder();
      return window.crypto.subtle.importKey(
        "raw",
        enc.encode(password),
        {name: "PBKDF2"},
        false,
        ["deriveBits", "deriveKey"]
      );
    }

    /*
    Given some key material and some random salt
    derive an AES-GCM key using PBKDF2.
    */
    function getKey(keyMaterial, salt) {
      return window.crypto.subtle.deriveKey(
        {
          "name": "PBKDF2",
          salt: salt,
          "iterations": 100000,
          "hash": "SHA-256"
        },
        keyMaterial,
        { "name": "AES-GCM", "length": 256},
        true,
        [ "wrapKey", "unwrapKey" ]
      );
    }

    /*
    Wrap the given key and write it into the "wrapped-key" space.
    */
    async function wrapCryptoKey(keyToWrap) {
      // get the key encryption key
      const keyMaterial = await getKeyMaterial();
      salt = window.crypto.getRandomValues(new Uint8Array(16));
      const wrappingKey = await getKey(keyMaterial, salt);
      iv = window.crypto.getRandomValues(new Uint8Array(12));

      const wrapped = await window.crypto.subtle.wrapKey(
        "jwk",
        keyToWrap,
        wrappingKey,
        {
          name: "AES-GCM",
          iv: iv
        }
      );

      const wrappedKeyBuffer = new Uint8Array(wrapped);

      const wrappedKeyOutput = document.querySelector(".wrapped-key");
      wrappedKeyOutput.classList.add("fade-in");
      wrappedKeyOutput.addEventListener("animationend", () => {
        wrappedKeyOutput.classList.remove("fade-in");
      });
      wrappedKeyOutput.textContent = `[${wrappedKeyBuffer}]`;
    }

    /*
    Generate a sign/verify key pair,
    then set up an event listener on the "Wrap" button.
    */
    window.crypto.subtle.generateKey(
      {
        name: "ECDSA",
        namedCurve: "P-384"
      },
      true,
      ["sign", "verify"]
    ).then((keyPair) => {
      const wrapButton = document.querySelector(".jwk");
      wrapButton.addEventListener("click", () => {
        wrapCryptoKey(keyPair.privateKey);
      });

    });

  })();
</script>
</body>
</html>
